.TH "QCPBars" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPBars \- A plottable representing a bar chart in a plot\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPAbstractPlottable1D< QCPBarsData >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBWidthType\fP { \fBwtAbsolute\fP, \fBwtAxisRectRatio\fP, \fBwtPlotCoords\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPBars\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "double \fBwidth\fP () const"
.br
.ti -1c
.RI "\fBWidthType\fP \fBwidthType\fP () const"
.br
.ti -1c
.RI "\fBQCPBarsGroup\fP * \fBbarsGroup\fP () const"
.br
.ti -1c
.RI "double \fBbaseValue\fP () const"
.br
.ti -1c
.RI "double \fBstackingGap\fP () const"
.br
.ti -1c
.RI "\fBQCPBars\fP * \fBbarBelow\fP () const"
.br
.ti -1c
.RI "\fBQCPBars\fP * \fBbarAbove\fP () const"
.br
.ti -1c
.RI "QSharedPointer< \fBQCPBarsDataContainer\fP > \fBdata\fP () const"
.br
.ti -1c
.RI "void \fBsetData\fP (QSharedPointer< \fBQCPBarsDataContainer\fP > \fBdata\fP)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)"
.br
.ti -1c
.RI "void \fBsetWidth\fP (double width)"
.br
.ti -1c
.RI "void \fBsetWidthType\fP (\fBWidthType\fP widthType)"
.br
.ti -1c
.RI "void \fBsetBarsGroup\fP (\fBQCPBarsGroup\fP *barsGroup)"
.br
.ti -1c
.RI "void \fBsetBaseValue\fP (double baseValue)"
.br
.ti -1c
.RI "void \fBsetStackingGap\fP (double pixels)"
.br
.ti -1c
.RI "void \fBaddData\fP (const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)"
.br
.ti -1c
.RI "void \fBaddData\fP (double key, double value)"
.br
.ti -1c
.RI "void \fBmoveBelow\fP (\fBQCPBars\fP *bars)"
.br
.ti -1c
.RI "void \fBmoveAbove\fP (\fBQCPBars\fP *bars)"
.br
.ti -1c
.RI "virtual \fBQCPDataSelection\fP \fBselectTestRect\fP (const QRectF &rect, bool onlySelectable) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QPointF \fBdataPixelPosition\fP (int index) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPAbstractPlottable1D< QCPBarsData >\fP
.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable1D\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "virtual int \fBdataCount\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataMainKey\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataSortKey\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataMainValue\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBdataValueRange\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QPointF \fBdataPixelPosition\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual bool \fBsortKeyIsMainKey\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPDataSelection\fP \fBselectTestRect\fP (const QRectF &rect, bool onlySelectable) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBfindBegin\fP (double sortKey, bool expandedRange=true) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBfindEnd\fP (double sortKey, bool expandedRange=true) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP () Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "QString \fBname\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedFill\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedScatters\fP () const"
.br
.ti -1c
.RI "QPen \fBpen\fP () const"
.br
.ti -1c
.RI "QBrush \fBbrush\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBkeyAxis\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBvalueAxis\fP () const"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBselectable\fP () const"
.br
.ti -1c
.RI "bool \fBselected\fP () const"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBselection\fP () const"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBselectionDecorator\fP () const"
.br
.ti -1c
.RI "void \fBsetName\fP (const QString &name)"
.br
.ti -1c
.RI "void \fBsetAntialiasedFill\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetAntialiasedScatters\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &pen)"
.br
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &brush)"
.br
.ti -1c
.RI "void \fBsetKeyAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "void \fBsetValueAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelectable\fP (\fBQCP::SelectionType\fP selectable)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelection\fP (\fBQCPDataSelection\fP \fBselection\fP)"
.br
.ti -1c
.RI "void \fBsetSelectionDecorator\fP (\fBQCPSelectionDecorator\fP *decorator)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const =0"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP ()"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const =0"
.br
.ti -1c
.RI "void \fBcoordsToPixels\fP (double key, double value, double &x, double &y) const"
.br
.ti -1c
.RI "const QPointF \fBcoordsToPixels\fP (double key, double value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (double x, double y, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (const QPointF &pixelPos, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBrescaleAxes\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleKeyAxis\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleValueAxis\fP (bool onlyEnlarge=false, bool inKeyRange=false) const"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP (\fBQCPLegend\fP *legend)"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP ()"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP (\fBQCPLegend\fP *legend) const"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.in +1c
.ti -1c
.RI "virtual int \fBdataCount\fP () const =0"
.br
.ti -1c
.RI "virtual double \fBdataMainKey\fP (int index) const =0"
.br
.ti -1c
.RI "virtual double \fBdataSortKey\fP (int index) const =0"
.br
.ti -1c
.RI "virtual double \fBdataMainValue\fP (int index) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBdataValueRange\fP (int index) const =0"
.br
.ti -1c
.RI "virtual QPointF \fBdataPixelPosition\fP (int index) const =0"
.br
.ti -1c
.RI "virtual bool \fBsortKeyIsMainKey\fP () const =0"
.br
.ti -1c
.RI "virtual \fBQCPDataSelection\fP \fBselectTestRect\fP (const QRectF &rect, bool onlySelectable) const =0"
.br
.ti -1c
.RI "virtual int \fBfindBegin\fP (double sortKey, bool expandedRange=true) const =0"
.br
.ti -1c
.RI "virtual int \fBfindEnd\fP (double sortKey, bool expandedRange=true) const =0"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBgetVisibleDataBounds\fP (QCPBarsDataContainer::const_iterator &begin, QCPBarsDataContainer::const_iterator &end) const"
.br
.ti -1c
.RI "QRectF \fBgetBarRect\fP (double key, double value) const"
.br
.ti -1c
.RI "void \fBgetPixelWidth\fP (double key, double &lower, double &upper) const"
.br
.ti -1c
.RI "double \fBgetStackedBaseValue\fP (double key, bool positive) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPAbstractPlottable1D< QCPBarsData >\fP
.in +1c
.ti -1c
.RI "void \fBgetDataSegments\fP (QList< \fBQCPDataRange\fP > &selectedSegments, QList< \fBQCPDataRange\fP > &unselectedSegments) const"
.br
.ti -1c
.RI "void \fBdrawPolyline\fP (\fBQCPPainter\fP *painter, const QVector< QPointF > &lineData) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE=0"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const =0"
.br
.ti -1c
.RI "void \fBapplyFillAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.ti -1c
.RI "void \fBapplyScattersAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBconnectBars\fP (\fBQCPBars\fP *lower, \fBQCPBars\fP *upper)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "double \fBmWidth\fP"
.br
.ti -1c
.RI "\fBWidthType\fP \fBmWidthType\fP"
.br
.ti -1c
.RI "\fBQCPBarsGroup\fP * \fBmBarsGroup\fP"
.br
.ti -1c
.RI "double \fBmBaseValue\fP"
.br
.ti -1c
.RI "double \fBmStackingGap\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPBars\fP > \fBmBarBelow\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPBars\fP > \fBmBarAbove\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPAbstractPlottable1D< QCPBarsData >\fP
.in +1c
.ti -1c
.RI "QSharedPointer< \fBQCPDataContainer\fP< \fBQCPBarsData\fP > > \fBmDataContainer\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "QString \fBmName\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedFill\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedScatters\fP"
.br
.ti -1c
.RI "QPen \fBmPen\fP"
.br
.ti -1c
.RI "QBrush \fBmBrush\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmKeyAxis\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmValueAxis\fP"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBmSelectable\fP"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBmSelection\fP"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBmSelectionDecorator\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCustomPlot\fP"
.br
.ti -1c
.RI "class \fBQCPLegend\fP"
.br
.ti -1c
.RI "class \fBQCPBarsGroup\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Signals inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "void \fBselectionChanged\fP (bool \fBselected\fP)"
.br
.ti -1c
.RI "void \fBselectionChanged\fP (const \fBQCPDataSelection\fP &\fBselection\fP)"
.br
.ti -1c
.RI "void \fBselectableChanged\fP (\fBQCP::SelectionType\fP selectable)"
.br
.in -1c

Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A plottable representing a bar chart in a plot\&. 


.PP
To plot data, assign it with the \fBsetData\fP or \fBaddData\fP functions\&.
.SH "Changing the appearance"
.PP
The appearance of the bars is determined by the pen and the brush (\fBsetPen\fP, \fBsetBrush\fP)\&. The width of the individual bars can be controlled with \fBsetWidthType\fP and \fBsetWidth\fP\&.
.PP
Bar charts are stackable\&. This means, two \fBQCPBars\fP plottables can be placed on top of each other (see \fBQCPBars::moveAbove\fP)\&. So when two bars are at the same key position, they will appear stacked\&.
.PP
If you would like to group multiple \fBQCPBars\fP plottables together so they appear side by side as shown below, use \fBQCPBarsGroup\fP\&.
.PP
.SH "Usage"
.PP
Like all data representing objects in \fBQCustomPlot\fP, the \fBQCPBars\fP is a plottable (\fBQCPAbstractPlottable\fP)\&. So the plottable-interface of \fBQCustomPlot\fP applies (\fBQCustomPlot::plottable\fP, \fBQCustomPlot::removePlottable\fP, etc\&.)
.PP
Usually, you first create an instance: 
.PP
.nf

.fi
.PP
 which registers it with the \fBQCustomPlot\fP instance of the passed axes\&. Note that this \fBQCustomPlot\fP instance takes ownership of the plottable, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. The newly created plottable can be modified, e\&.g\&.: 
.PP
.nf

.fi
.PP
 
.PP
Definition at line \fB5471\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQCPBars::WidthType\fP"
Defines the ways the width of the bar can be specified\&. Thus it defines what the number passed to \fBsetWidth\fP actually means\&.
.PP
\fBSee also\fP
.RS 4
\fBsetWidthType\fP, \fBsetWidth\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIwtAbsolute \fP\fP
Bar width is in absolute pixels\&. 
.TP
\fB\fIwtAxisRectRatio \fP\fP
Bar width is given by a fraction of the axis rect size\&. 
.TP
\fB\fIwtPlotCoords \fP\fP
Bar width is in key coordinates and thus scales with the key axis range\&. 
.PP
Definition at line \fB5490\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPBars::QCPBars (\fBQCPAxis\fP * keyAxis, \fBQCPAxis\fP * valueAxis)\fC [explicit]\fP"
Constructs a bar chart which uses \fIkeyAxis\fP as its key axis ('x') and \fIvalueAxis\fP as its value axis ('y')\&. \fIkeyAxis\fP and \fIvalueAxis\fP must reside in the same \fBQCustomPlot\fP instance and not have the same orientation\&. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though\&.
.PP
The created \fBQCPBars\fP is automatically registered with the \fBQCustomPlot\fP instance inferred from \fIkeyAxis\fP\&. This \fBQCustomPlot\fP instance takes ownership of the \fBQCPBars\fP, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. 
.PP
Definition at line \fB23588\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPBars::~QCPBars ()\fC [virtual]\fP"

.PP
Definition at line \fB23604\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void QCPBars::addData (const QVector< double > & keys, const QVector< double > & values, bool alreadySorted = \fCfalse\fP)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the provided points in \fIkeys\fP and \fIvalues\fP to the current data\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
If you can guarantee that the passed data points are sorted by \fIkeys\fP in ascending order, you can set \fIalreadySorted\fP to true, to improve performance by saving a sorting run\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB23728\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::addData (double key, double value)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. Adds the provided data point as \fIkey\fP and \fIvalue\fP to the current data\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB23753\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPBars\fP * QCPBars::barAbove () const\fC [inline]\fP"
Returns the bars plottable that is directly above this bars plottable\&. If there is no such plottable, returns 0\&.
.PP
\fBSee also\fP
.RS 4
\fBbarBelow\fP, \fBmoveBelow\fP, \fBmoveAbove\fP 
.RE
.PP

.PP
Definition at line \fB5506\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPBars\fP * QCPBars::barBelow () const\fC [inline]\fP"
Returns the bars plottable that is directly below this bars plottable\&. If there is no such plottable, returns 0\&.
.PP
\fBSee also\fP
.RS 4
\fBbarAbove\fP, \fBmoveBelow\fP, \fBmoveAbove\fP 
.RE
.PP

.PP
Definition at line \fB5505\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPBarsGroup\fP * QCPBars::barsGroup () const\fC [inline]\fP"

.PP
Definition at line \fB5502\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPBars::baseValue () const\fC [inline]\fP"

.PP
Definition at line \fB5503\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPBars::connectBars (\fBQCPBars\fP * lower, \fBQCPBars\fP * upper)\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line \fB24236\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSharedPointer< \fBQCPBarsDataContainer\fP > QCPBars::data () const\fC [inline]\fP"
Returns a shared pointer to the internal data storage of type \fBQCPBarsDataContainer\fP\&. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular \fBsetData\fP or \fBaddData\fP methods\&. 
.PP
Definition at line \fB5507\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPointF QCPBars::dataPixelPosition (int index) const\fC [virtual]\fP"

.PP
Returns the pixel position on the widget surface at which the data point at the given \fIindex\fP appears\&.
.PP
Usually this corresponds to the point of \fBdataMainKey/\fP dataMainValue, in pixel coordinates\&. However, depending on the plottable, this might be a different apparent position than just a coord-to-pixel transform of those values\&. For example, \fBQCPBars\fP apparent data values can be shifted depending on their stacking, bar grouping or configured base value\&.   
.PP
Reimplemented from \fBQCPAbstractPlottable1D< QCPBarsData >\fP\&.
.PP
Definition at line \fB23957\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::draw (\fBQCPPainter\fP * painter)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB23980\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::drawLegendIcon (\fBQCPPainter\fP * painter, const QRectF & rect) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB24029\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QRectF QCPBars::getBarRect (double key, double value) const\fC [protected]\fP"

.PP
Definition at line \fB24114\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPBars::getKeyRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP) const\fC [virtual]\fP"
Returns the coordinate range that all data in this plottable span in the key axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetValueRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB23878\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::getPixelWidth (double key, double & lower, double & upper) const\fC [protected]\fP"

.PP
Definition at line \fB24151\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPBars::getStackedBaseValue (double key, bool positive) const\fC [protected]\fP"

.PP
Definition at line \fB24201\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPBars::getValueRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP, const \fBQCPRange\fP & inKeyRange = \fC\fBQCPRange\fP()\fP) const\fC [virtual]\fP"
Returns the coordinate range that the data points in the specified key range (\fIinKeyRange\fP) span in the value axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
If \fIinKeyRange\fP has both lower and upper bound set to zero (is equal to \fC\fBQCPRange()\fP\fP), all data points are considered, without any restriction on the keys\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetKeyRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB23917\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::getVisibleDataBounds (QCPBarsDataContainer::const_iterator & begin, QCPBarsDataContainer::const_iterator & end) const\fC [protected]\fP"

.PP
Definition at line \fB24054\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::moveAbove (\fBQCPBars\fP * bars)"
Moves this bars plottable above \fIbars\fP\&. In other words, the bars of this plottable will appear above the bars of \fIbars\fP\&. The move target \fIbars\fP must use the same key and value axis as this plottable\&.
.PP
Inserting into and removing from existing bar stacking is handled gracefully\&. If \fIbars\fP already has a bars object above itself, this bars object is inserted between the two\&. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation\&.
.PP
To remove this bars plottable from any stacking, set \fIbars\fP to 0\&.
.PP
\fBSee also\fP
.RS 4
\fBmoveBelow\fP, \fBbarBelow\fP, \fBbarAbove\fP 
.RE
.PP

.PP
Definition at line \fB23805\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::moveBelow (\fBQCPBars\fP * bars)"
Moves this bars plottable below \fIbars\fP\&. In other words, the bars of this plottable will appear below the bars of \fIbars\fP\&. The move target \fIbars\fP must use the same key and value axis as this plottable\&.
.PP
Inserting into and removing from existing bar stacking is handled gracefully\&. If \fIbars\fP already has a bars object below itself, this bars object is inserted between the two\&. If this bars object is already between two other bars, the two other bars will be stacked on top of each other after the operation\&.
.PP
To remove this bars plottable from any stacking, set \fIbars\fP to 0\&.
.PP
\fBSee also\fP
.RS 4
\fBmoveBelow\fP, \fBbarAbove\fP, \fBbarBelow\fP 
.RE
.PP

.PP
Definition at line \fB23772\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPBars::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [virtual]\fP"
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like\&. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry\&.
.PP
\\seebaseclassmethod 
.PP
Reimplemented from \fBQCPAbstractPlottable1D< QCPBarsData >\fP\&.
.PP
Definition at line \fB23848\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPDataSelection\fP QCPBars::selectTestRect (const QRectF & rect, bool onlySelectable) const\fC [virtual]\fP"

.PP
Returns a data selection containing all the data points of this plottable which are contained (or hit by) \fIrect\fP\&. This is used mainly in the selection rect interaction for data selection (\fBdata selection mechanism\fP)\&.
.PP
If \fIonlySelectable\fP is true, an empty \fBQCPDataSelection\fP is returned if this plottable is not selectable (i\&.e\&. if \fBQCPAbstractPlottable::setSelectable\fP is \fBQCP::stNone\fP)\&.
.PP
\fBNote\fP
.RS 4
\fIrect\fP must be a normalized rect (positive or zero width and height)\&. This is especially important when using the rect of \fBQCPSelectionRect::accepted\fP, which is not necessarily normalized\&. Use \fCQRect::normalized()\fP when passing a rect which might not be normalized\&.   
.RE
.PP

.PP
Reimplemented from \fBQCPAbstractPlottable1D< QCPBarsData >\fP\&.
.PP
Definition at line \fB23827\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setBarsGroup (\fBQCPBarsGroup\fP * barsGroup)"
Sets to which \fBQCPBarsGroup\fP this \fBQCPBars\fP instance belongs to\&. Alternatively, you can also use \fBQCPBarsGroup::append\fP\&.
.PP
To remove this \fBQCPBars\fP from any group, set \fIbarsGroup\fP to 0\&. 
.PP
Definition at line \fB23678\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setBaseValue (double baseValue)"
Sets the base value of this bars plottable\&.
.PP
The base value defines where on the value coordinate the bars start\&. How far the bars extend from the base value is given by their individual value data\&. For example, if the base value is set to 1, a bar with data value 2 will have its lowest point at value coordinate 1 and highest point at 3\&.
.PP
For stacked bars, only the base value of the bottom-most \fBQCPBars\fP has meaning\&.
.PP
The default base value is 0\&. 
.PP
Definition at line \fB23701\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setData (const QVector< double > & keys, const QVector< double > & values, bool alreadySorted = \fCfalse\fP)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data with the provided points in \fIkeys\fP and \fIvalues\fP\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
If you can guarantee that the passed data points are sorted by \fIkeys\fP in ascending order, you can set \fIalreadySorted\fP to true, to improve performance by saving a sorting run\&.
.PP
\fBSee also\fP
.RS 4
\fBaddData\fP 
.RE
.PP

.PP
Definition at line \fB23642\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setData (QSharedPointer< \fBQCPBarsDataContainer\fP > data)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data container with the provided \fIdata\fP container\&.
.PP
Since a QSharedPointer is used, multiple \fBQCPBars\fP may share the same data container safely\&. Modifying the data in the container will then affect all bars that share the container\&. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: 
.PP
.nf

.fi
.PP
.PP
If you do not wish to share containers, but create a copy from an existing container, rather use the \fBQCPDataContainer<DataType>::set\fP method on the bar's data container directly: 
.PP
.nf

.fi
.PP
.PP
\fBSee also\fP
.RS 4
\fBaddData\fP 
.RE
.PP

.PP
Definition at line \fB23626\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setStackingGap (double pixels)"
If this bars plottable is stacked on top of another bars plottable (\fBmoveAbove\fP), this method allows specifying a distance in \fIpixels\fP, by which the drawn bar rectangles will be separated by the bars below it\&. 
.PP
Definition at line \fB23711\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setWidth (double width)"
Sets the width of the bars\&.
.PP
How the number passed as \fIwidth\fP is interpreted (e\&.g\&. screen pixels, plot coordinates,\&.\&.\&.), depends on the currently set width type, see \fBsetWidthType\fP and \fBWidthType\fP\&. 
.PP
Definition at line \fB23654\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPBars::setWidthType (\fBQCPBars::WidthType\fP widthType)"
Sets how the width of the bars is defined\&. See the documentation of \fBWidthType\fP for an explanation of the possible values for \fIwidthType\fP\&.
.PP
The default value is \fBwtPlotCoords\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBsetWidth\fP 
.RE
.PP

.PP
Definition at line \fB23667\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPBars::stackingGap () const\fC [inline]\fP"

.PP
Definition at line \fB5504\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPBars::width () const\fC [inline]\fP"

.PP
Definition at line \fB5500\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBWidthType\fP QCPBars::widthType () const\fC [inline]\fP"

.PP
Definition at line \fB5501\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBQCPBarsGroup\fP\fC [friend]\fP"

.PP
Definition at line \fB5553\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCPLegend\fP\fC [friend]\fP"

.PP
Definition at line \fB5552\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCustomPlot\fP\fC [friend]\fP"

.PP
Definition at line \fB5551\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "QPointer<\fBQCPBars\fP> QCPBars::mBarAbove\fC [protected]\fP"

.PP
Definition at line \fB5538\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPointer<\fBQCPBars\fP> QCPBars::mBarBelow\fC [protected]\fP"

.PP
Definition at line \fB5538\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPBarsGroup\fP* QCPBars::mBarsGroup\fC [protected]\fP"

.PP
Definition at line \fB5535\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPBars::mBaseValue\fC [protected]\fP"

.PP
Definition at line \fB5536\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPBars::mStackingGap\fC [protected]\fP"

.PP
Definition at line \fB5537\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPBars::mWidth\fC [protected]\fP"

.PP
Definition at line \fB5533\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBWidthType\fP QCPBars::mWidthType\fC [protected]\fP"

.PP
Definition at line \fB5534\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
