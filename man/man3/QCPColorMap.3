.TH "QCPColorMap" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPColorMap \- A plottable representing a two-dimensional color map in a plot\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPAbstractPlottable\fP\&.
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBdataRangeChanged\fP (const \fBQCPRange\fP &newRange)"
.br
.ti -1c
.RI "void \fBdataScaleTypeChanged\fP (\fBQCPAxis::ScaleType\fP scaleType)"
.br
.ti -1c
.RI "void \fBgradientChanged\fP (const \fBQCPColorGradient\fP &newGradient)"
.br
.in -1c

Signals inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "void \fBselectionChanged\fP (bool \fBselected\fP)"
.br
.ti -1c
.RI "void \fBselectionChanged\fP (const \fBQCPDataSelection\fP &\fBselection\fP)"
.br
.ti -1c
.RI "void \fBselectableChanged\fP (\fBQCP::SelectionType\fP selectable)"
.br
.in -1c

Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPColorMap\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "\fBQCPColorMapData\fP * \fBdata\fP () const"
.br
.ti -1c
.RI "\fBQCPRange\fP \fBdataRange\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis::ScaleType\fP \fBdataScaleType\fP () const"
.br
.ti -1c
.RI "bool \fBinterpolate\fP () const"
.br
.ti -1c
.RI "bool \fBtightBoundary\fP () const"
.br
.ti -1c
.RI "\fBQCPColorGradient\fP \fBgradient\fP () const"
.br
.ti -1c
.RI "\fBQCPColorScale\fP * \fBcolorScale\fP () const"
.br
.ti -1c
.RI "void \fBsetData\fP (\fBQCPColorMapData\fP *\fBdata\fP, bool copy=false)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetDataRange\fP (const \fBQCPRange\fP &dataRange)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetDataScaleType\fP (\fBQCPAxis::ScaleType\fP scaleType)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetGradient\fP (const \fBQCPColorGradient\fP &gradient)"
.br
.ti -1c
.RI "void \fBsetInterpolate\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetTightBoundary\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetColorScale\fP (\fBQCPColorScale\fP *colorScale)"
.br
.ti -1c
.RI "void \fBrescaleDataRange\fP (bool recalculateDataBounds=false)"
.br
.ti -1c
.RI "Q_SLOT void \fBupdateLegendIcon\fP (Qt::TransformationMode transformMode=Qt::SmoothTransformation, const QSize &thumbSize=QSize(32, 18))"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "QString \fBname\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedFill\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedScatters\fP () const"
.br
.ti -1c
.RI "QPen \fBpen\fP () const"
.br
.ti -1c
.RI "QBrush \fBbrush\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBkeyAxis\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBvalueAxis\fP () const"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBselectable\fP () const"
.br
.ti -1c
.RI "bool \fBselected\fP () const"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBselection\fP () const"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBselectionDecorator\fP () const"
.br
.ti -1c
.RI "void \fBsetName\fP (const QString &name)"
.br
.ti -1c
.RI "void \fBsetAntialiasedFill\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetAntialiasedScatters\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &pen)"
.br
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &brush)"
.br
.ti -1c
.RI "void \fBsetKeyAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "void \fBsetValueAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelectable\fP (\fBQCP::SelectionType\fP selectable)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelection\fP (\fBQCPDataSelection\fP \fBselection\fP)"
.br
.ti -1c
.RI "void \fBsetSelectionDecorator\fP (\fBQCPSelectionDecorator\fP *decorator)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const =0"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP ()"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const =0"
.br
.ti -1c
.RI "void \fBcoordsToPixels\fP (double key, double value, double &x, double &y) const"
.br
.ti -1c
.RI "const QPointF \fBcoordsToPixels\fP (double key, double value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (double x, double y, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (const QPointF &pixelPos, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBrescaleAxes\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleKeyAxis\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleValueAxis\fP (bool onlyEnlarge=false, bool inKeyRange=false) const"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP (\fBQCPLegend\fP *legend)"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP ()"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP (\fBQCPLegend\fP *legend) const"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBupdateMapImage\fP ()"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const Q_DECL_OVERRIDE"
.br
.in -1c

Protected Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE=0"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const =0"
.br
.ti -1c
.RI "void \fBapplyFillAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.ti -1c
.RI "void \fBapplyScattersAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBQCPRange\fP \fBmDataRange\fP"
.br
.ti -1c
.RI "\fBQCPAxis::ScaleType\fP \fBmDataScaleType\fP"
.br
.ti -1c
.RI "\fBQCPColorMapData\fP * \fBmMapData\fP"
.br
.ti -1c
.RI "\fBQCPColorGradient\fP \fBmGradient\fP"
.br
.ti -1c
.RI "bool \fBmInterpolate\fP"
.br
.ti -1c
.RI "bool \fBmTightBoundary\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPColorScale\fP > \fBmColorScale\fP"
.br
.ti -1c
.RI "QImage \fBmMapImage\fP"
.br
.ti -1c
.RI "QImage \fBmUndersampledMapImage\fP"
.br
.ti -1c
.RI "QPixmap \fBmLegendIcon\fP"
.br
.ti -1c
.RI "bool \fBmMapImageInvalidated\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "QString \fBmName\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedFill\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedScatters\fP"
.br
.ti -1c
.RI "QPen \fBmPen\fP"
.br
.ti -1c
.RI "QBrush \fBmBrush\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmKeyAxis\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmValueAxis\fP"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBmSelectable\fP"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBmSelection\fP"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBmSelectionDecorator\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCustomPlot\fP"
.br
.ti -1c
.RI "class \fBQCPLegend\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A plottable representing a two-dimensional color map in a plot\&. 


.PP
The data is stored in the class \fBQCPColorMapData\fP, which can be accessed via the \fBdata()\fP method\&.
.PP
A color map has three dimensions to represent a data point: The \fIkey\fP dimension, the \fIvalue\fP dimension and the \fIdata\fP dimension\&. As with other plottables such as graphs, \fIkey\fP and \fIvalue\fP correspond to two orthogonal axes on the \fBQCustomPlot\fP surface that you specify in the \fBQCPColorMap\fP constructor\&. The \fIdata\fP dimension however is encoded as the color of the point at (\fIkey\fP, \fIvalue\fP)\&.
.PP
Set the number of points (or \fIcells\fP) in the key/value dimension via \fBQCPColorMapData::setSize\fP\&. The plot coordinate range over which these points will be displayed is specified via \fBQCPColorMapData::setRange\fP\&. The first cell will be centered on the lower range boundary and the last cell will be centered on the upper range boundary\&. The data can be set by either accessing the cells directly with \fBQCPColorMapData::setCell\fP or by addressing the cells via their plot coordinates with \fBQCPColorMapData::setData\fP\&. If possible, you should prefer setCell, since it doesn't need to do any coordinate transformation and thus performs a bit better\&.
.PP
The cell with index (0, 0) is at the bottom left, if the color map uses normal (i\&.e\&. not reversed) key and value axes\&.
.PP
To show the user which colors correspond to which \fIdata\fP values, a \fBQCPColorScale\fP is typically placed to the right of the axis rect\&. See the documentation there for details on how to add and use a color scale\&.
.SH "Changing the appearance"
.PP
The central part of the appearance is the color gradient, which can be specified via \fBsetGradient\fP\&. See the documentation of \fBQCPColorGradient\fP for details on configuring a color gradient\&.
.PP
The \fIdata\fP range that is mapped to the colors of the gradient can be specified with \fBsetDataRange\fP\&. To make the data range encompass the whole data set minimum to maximum, call \fBrescaleDataRange\fP\&.
.SH "Transparency"
.PP
Transparency in color maps can be achieved by two mechanisms\&. On one hand, you can specify alpha values for color stops of the \fBQCPColorGradient\fP, via the regular QColor interface\&. This will cause the color map data which gets mapped to colors around those color stops to appear with the accordingly interpolated transparency\&.
.PP
On the other hand you can also directly apply an alpha value to each cell independent of its data, by using the alpha map feature of \fBQCPColorMapData\fP\&. The relevant methods are \fBQCPColorMapData::setAlpha\fP, \fBQCPColorMapData::fillAlpha\fP and \fBQCPColorMapData::clearAlpha()\fP\&.
.PP
The two transparencies will be joined together in the plot and otherwise not interfere with each other\&. They are mixed in a multiplicative matter, so an alpha of e\&.g\&. 50% (128/255) in both modes simultaneously, will result in a total transparency of 25% (64/255)\&.
.SH "Usage"
.PP
Like all data representing objects in \fBQCustomPlot\fP, the \fBQCPColorMap\fP is a plottable (\fBQCPAbstractPlottable\fP)\&. So the plottable-interface of \fBQCustomPlot\fP applies (\fBQCustomPlot::plottable\fP, \fBQCustomPlot::removePlottable\fP, etc\&.)
.PP
Usually, you first create an instance: 
.PP
.nf

.fi
.PP
 which registers it with the \fBQCustomPlot\fP instance of the passed axes\&. Note that this \fBQCustomPlot\fP instance takes ownership of the plottable, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. The newly created plottable can be modified, e\&.g\&.: 
.PP
.nf

.fi
.PP
.PP
\fBNote\fP
.RS 4
The \fBQCPColorMap\fP always displays the data at equal key/value intervals, even if the key or value axis is set to a logarithmic scaling\&. If you want to use \fBQCPColorMap\fP with logarithmic axes, you shouldn't use the \fBQCPColorMapData::setData\fP method as it uses a linear transformation to determine the cell index\&. Rather directly access the cell index with \fBQCPColorMapData::setCell\fP\&. 
.RE
.PP

.PP
Definition at line \fB5737\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPColorMap::QCPColorMap (\fBQCPAxis\fP * keyAxis, \fBQCPAxis\fP * valueAxis)\fC [explicit]\fP"
Constructs a color map with the specified \fIkeyAxis\fP and \fIvalueAxis\fP\&.
.PP
The created \fBQCPColorMap\fP is automatically registered with the \fBQCustomPlot\fP instance inferred from \fIkeyAxis\fP\&. This \fBQCustomPlot\fP instance takes ownership of the \fBQCPColorMap\fP, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. 
.PP
Definition at line \fB25575\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPColorMap::~QCPColorMap ()\fC [virtual]\fP"

.PP
Definition at line \fB25586\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBQCPColorScale\fP * QCPColorMap::colorScale () const\fC [inline]\fP"

.PP
Definition at line \fB5759\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPColorMapData\fP * QCPColorMap::data () const\fC [inline]\fP"
Returns a pointer to the internal data storage of type \fBQCPColorMapData\fP\&. Access this to modify data points (cells) and the color map key/value range\&.
.PP
\fBSee also\fP
.RS 4
\fBsetData\fP 
.RE
.PP

.PP
Definition at line \fB5753\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPRange\fP QCPColorMap::dataRange () const\fC [inline]\fP"

.PP
Definition at line \fB5754\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPColorMap::dataRangeChanged (const \fBQCPRange\fP & newRange)\fC [signal]\fP"
This signal is emitted when the data range changes\&.
.PP
\fBSee also\fP
.RS 4
\fBsetDataRange\fP 
.RE
.PP

.SS "\fBQCPAxis::ScaleType\fP QCPColorMap::dataScaleType () const\fC [inline]\fP"

.PP
Definition at line \fB5755\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPColorMap::dataScaleTypeChanged (\fBQCPAxis::ScaleType\fP scaleType)\fC [signal]\fP"
This signal is emitted when the data scale type changes\&.
.PP
\fBSee also\fP
.RS 4
\fBsetDataScaleType\fP 
.RE
.PP

.SS "void QCPColorMap::draw (\fBQCPPainter\fP * painter)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB25966\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::drawLegendIcon (\fBQCPPainter\fP * painter, const QRectF & rect) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB26035\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPColorMap::getKeyRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP) const\fC [virtual]\fP"
Returns the coordinate range that all data in this plottable span in the key axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetValueRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB25822\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPColorMap::getValueRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP, const \fBQCPRange\fP & inKeyRange = \fC\fBQCPRange\fP()\fP) const\fC [virtual]\fP"
Returns the coordinate range that the data points in the specified key range (\fIinKeyRange\fP) span in the value axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
If \fIinKeyRange\fP has both lower and upper bound set to zero (is equal to \fC\fBQCPRange()\fP\fP), all data points are considered, without any restriction on the keys\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetKeyRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB25844\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPColorGradient\fP QCPColorMap::gradient () const\fC [inline]\fP"

.PP
Definition at line \fB5758\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPColorMap::gradientChanged (const \fBQCPColorGradient\fP & newGradient)\fC [signal]\fP"
This signal is emitted when the gradient changes\&.
.PP
\fBSee also\fP
.RS 4
\fBsetGradient\fP 
.RE
.PP

.SS "bool QCPColorMap::interpolate () const\fC [inline]\fP"

.PP
Definition at line \fB5756\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPColorMap::rescaleDataRange (bool recalculateDataBounds = \fCfalse\fP)"
Sets the data range (\fBsetDataRange\fP) to span the minimum and maximum values that occur in the current data set\&. This corresponds to the \fBrescaleKeyAxis\fP or \fBrescaleValueAxis\fP methods, only for the third data dimension of the color map\&.
.PP
The minimum and maximum values of the data set are buffered in the internal \fBQCPColorMapData\fP instance (\fBdata\fP)\&. As data is updated via its \fBQCPColorMapData::setCell\fP or \fBQCPColorMapData::setData\fP, the buffered minimum and maximum values are updated, too\&. For performance reasons, however, they are only updated in an expanding fashion\&. So the buffered maximum can only increase and the buffered minimum can only decrease\&. In consequence, changes to the data that actually lower the maximum of the data set (by overwriting the cell holding the current maximum with a smaller value), aren't recognized and the buffered maximum overestimates the true maximum of the data set\&. The same happens for the buffered minimum\&. To recalculate the true minimum and maximum by explicitly looking at each cell, the method \fBQCPColorMapData::recalculateDataBounds\fP can be used\&. For convenience, setting the parameter \fIrecalculateDataBounds\fP calls this method before setting the data range to the buffered minimum and maximum\&.
.PP
\fBSee also\fP
.RS 4
\fBsetDataRange\fP 
.RE
.PP

.PP
Definition at line \fB25764\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPColorMap::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [virtual]\fP"
This function is used to decide whether a click hits a layerable object or not\&.
.PP
\fIpos\fP is a point in pixel coordinates on the \fBQCustomPlot\fP surface\&. This function returns the shortest pixel distance of this point to the object\&. If the object is either invisible or the distance couldn't be determined, -1\&.0 is returned\&. Further, if \fIonlySelectable\fP is true and the object is not selectable, -1\&.0 is returned, too\&.
.PP
If the object is represented not by single lines but by an area like a \fBQCPItemText\fP or the bars of a \fBQCPBars\fP plottable, a click inside the area should also be considered a hit\&. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance\&. (typically the selectionTolerance multiplied by 0\&.99)\&.
.PP
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i\&.e\&. closer than 0\&.99*selectionTolerance)\&.
.PP
The actual setting of the selection state is not done by this function\&. This is handled by the parent \fBQCustomPlot\fP when the mouseReleaseEvent occurs, and the finally selected object is notified via the \fBselectEvent/\fP deselectEvent methods\&.
.PP
\fIdetails\fP is an optional output parameter\&. Every layerable subclass may place any information in \fIdetails\fP\&. This information will be passed to \fBselectEvent\fP when the parent \fBQCustomPlot\fP decides on the basis of this selectTest call, that the object was successfully selected\&. The subsequent call to \fBselectEvent\fP will carry the \fIdetails\fP\&. This is useful for multi-part objects (like \fBQCPAxis\fP)\&. This way, a possibly complex calculation to decide which part was clicked is only done once in \fBselectTest\fP\&. The result (i\&.e\&. the actually clicked part) can then be placed in \fIdetails\fP\&. So in the subsequent \fBselectEvent\fP, the decision which part was selected doesn't have to be done a second time for a single selection operation\&.
.PP
You may pass 0 as \fIdetails\fP to indicate that you are not interested in those selection details\&.
.PP
\fBSee also\fP
.RS 4
selectEvent, deselectEvent, \fBmousePressEvent\fP, \fBwheelEvent\fP, \fBQCustomPlot::setInteractions\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB25799\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setColorScale (\fBQCPColorScale\fP * colorScale)"
Associates the color scale \fIcolorScale\fP with this color map\&.
.PP
This means that both the color scale and the color map synchronize their gradient, data range and data scale type (\fBsetGradient\fP, \fBsetDataRange\fP, \fBsetDataScaleType\fP)\&. Multiple color maps can be associated with one single color scale\&. This causes the color maps to also synchronize those properties, via the mutual color scale\&.
.PP
This function causes the color map to adopt the current color gradient, data range and data scale type of \fIcolorScale\fP\&. After this call, you may change these properties at either the color map or the color scale, and the setting will be applied to both\&.
.PP
Pass 0 as \fIcolorScale\fP to disconnect the color scale from this color map again\&. 
.PP
Definition at line \fB25718\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setData (\fBQCPColorMapData\fP * data, bool copy = \fCfalse\fP)"
Replaces the current \fBdata\fP with the provided \fIdata\fP\&.
.PP
If \fIcopy\fP is set to true, the \fIdata\fP object will only be copied\&. if false, the color map takes ownership of the passed data and replaces the internal data pointer with it\&. This is significantly faster than copying for large datasets\&. 
.PP
Definition at line \fB25598\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setDataRange (const \fBQCPRange\fP & dataRange)"
Sets the data range of this color map to \fIdataRange\fP\&. The data range defines which data values are mapped to the color gradient\&.
.PP
To make the data range span the full range of the data set, use \fBrescaleDataRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBQCPColorScale::setDataRange\fP 
.RE
.PP

.PP
Definition at line \fB25624\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setDataScaleType (\fBQCPAxis::ScaleType\fP scaleType)"
Sets whether the data is correlated with the color gradient linearly or logarithmically\&.
.PP
\fBSee also\fP
.RS 4
\fBQCPColorScale::setDataScaleType\fP 
.RE
.PP

.PP
Definition at line \fB25643\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setGradient (const \fBQCPColorGradient\fP & gradient)"
Sets the color gradient that is used to represent the data\&. For more details on how to create an own gradient or use one of the preset gradients, see \fBQCPColorGradient\fP\&.
.PP
The colors defined by the gradient will be used to represent data values in the currently set data range, see \fBsetDataRange\fP\&. Data points that are outside this data range will either be colored uniformly with the respective gradient boundary color, or the gradient will repeat, depending on \fBQCPColorGradient::setPeriodic\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBQCPColorScale::setGradient\fP 
.RE
.PP

.PP
Definition at line \fB25666\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setInterpolate (bool enabled)"
Sets whether the color map image shall use bicubic interpolation when displaying the color map shrinked or expanded, and not at a 1:1 pixel-to-data scale\&.
.PP
 
.PP
Definition at line \fB25682\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::setTightBoundary (bool enabled)"
Sets whether the outer most data rows and columns are clipped to the specified key and value range (see \fBQCPColorMapData::setKeyRange\fP, \fBQCPColorMapData::setValueRange\fP)\&.
.PP
if \fIenabled\fP is set to false, the data points at the border of the color map are drawn with the same width and height as all other data points\&. Since the data points are represented by rectangles of one color centered on the data coordinate, this means that the shown color map extends by half a data point over the specified key/value range in each direction\&.
.PP
 
.PP
Definition at line \fB25699\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPColorMap::tightBoundary () const\fC [inline]\fP"

.PP
Definition at line \fB5757\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPColorMap::updateLegendIcon (Qt::TransformationMode transformMode = \fCQt::SmoothTransformation\fP, const QSize & thumbSize = \fCQSize(32, 18)\fP)"
Takes the current appearance of the color map and updates the legend icon, which is used to represent this color map in the legend (see \fBQCPLegend\fP)\&.
.PP
The \fItransformMode\fP specifies whether the rescaling is done by a faster, low quality image scaling algorithm (Qt::FastTransformation) or by a slower, higher quality algorithm (Qt::SmoothTransformation)\&.
.PP
The current color map appearance is scaled down to \fIthumbSize\fP\&. Ideally, this should be equal to the size of the legend icon (see \fBQCPLegend::setIconSize\fP)\&. If it isn't exactly the configured legend icon size, the thumb will be rescaled during drawing of the legend item\&.
.PP
\fBSee also\fP
.RS 4
\fBsetDataRange\fP 
.RE
.PP

.PP
Definition at line \fB25785\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPColorMap::updateMapImage ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB25888\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBQCPLegend\fP\fC [friend]\fP"

.PP
Definition at line \fB5807\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCustomPlot\fP\fC [friend]\fP"

.PP
Definition at line \fB5806\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "QPointer<\fBQCPColorScale\fP> QCPColorMap::mColorScale\fC [protected]\fP"

.PP
Definition at line \fB5792\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPRange\fP QCPColorMap::mDataRange\fC [protected]\fP"

.PP
Definition at line \fB5786\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPAxis::ScaleType\fP QCPColorMap::mDataScaleType\fC [protected]\fP"

.PP
Definition at line \fB5787\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPColorGradient\fP QCPColorMap::mGradient\fC [protected]\fP"

.PP
Definition at line \fB5789\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPColorMap::mInterpolate\fC [protected]\fP"

.PP
Definition at line \fB5790\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPixmap QCPColorMap::mLegendIcon\fC [protected]\fP"

.PP
Definition at line \fB5796\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPColorMapData\fP* QCPColorMap::mMapData\fC [protected]\fP"

.PP
Definition at line \fB5788\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QImage QCPColorMap::mMapImage\fC [protected]\fP"

.PP
Definition at line \fB5795\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPColorMap::mMapImageInvalidated\fC [protected]\fP"

.PP
Definition at line \fB5797\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPColorMap::mTightBoundary\fC [protected]\fP"

.PP
Definition at line \fB5791\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QImage QCPColorMap::mUndersampledMapImage\fC [protected]\fP"

.PP
Definition at line \fB5795\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
