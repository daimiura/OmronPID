.TH "QCPCurve" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPCurve \- A plottable representing a parametric curve in a plot\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPAbstractPlottable1D< QCPCurveData >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBLineStyle\fP { \fBlsNone\fP, \fBlsLine\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPCurve\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "QSharedPointer< \fBQCPCurveDataContainer\fP > \fBdata\fP () const"
.br
.ti -1c
.RI "\fBQCPScatterStyle\fP \fBscatterStyle\fP () const"
.br
.ti -1c
.RI "int \fBscatterSkip\fP () const"
.br
.ti -1c
.RI "\fBLineStyle\fP \fBlineStyle\fP () const"
.br
.ti -1c
.RI "void \fBsetData\fP (QSharedPointer< \fBQCPCurveDataContainer\fP > \fBdata\fP)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QVector< double > &t, const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QVector< double > &keys, const QVector< double > &values)"
.br
.ti -1c
.RI "void \fBsetScatterStyle\fP (const \fBQCPScatterStyle\fP &style)"
.br
.ti -1c
.RI "void \fBsetScatterSkip\fP (int skip)"
.br
.ti -1c
.RI "void \fBsetLineStyle\fP (\fBLineStyle\fP style)"
.br
.ti -1c
.RI "void \fBaddData\fP (const QVector< double > &t, const QVector< double > &keys, const QVector< double > &values, bool alreadySorted=false)"
.br
.ti -1c
.RI "void \fBaddData\fP (const QVector< double > &keys, const QVector< double > &values)"
.br
.ti -1c
.RI "void \fBaddData\fP (double t, double key, double value)"
.br
.ti -1c
.RI "void \fBaddData\fP (double key, double value)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPAbstractPlottable1D< QCPCurveData >\fP
.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable1D\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "virtual int \fBdataCount\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataMainKey\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataSortKey\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBdataMainValue\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBdataValueRange\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QPointF \fBdataPixelPosition\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual bool \fBsortKeyIsMainKey\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPDataSelection\fP \fBselectTestRect\fP (const QRectF &rect, bool onlySelectable) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBfindBegin\fP (double sortKey, bool expandedRange=true) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBfindEnd\fP (double sortKey, bool expandedRange=true) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP () Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "QString \fBname\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedFill\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedScatters\fP () const"
.br
.ti -1c
.RI "QPen \fBpen\fP () const"
.br
.ti -1c
.RI "QBrush \fBbrush\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBkeyAxis\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBvalueAxis\fP () const"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBselectable\fP () const"
.br
.ti -1c
.RI "bool \fBselected\fP () const"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBselection\fP () const"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBselectionDecorator\fP () const"
.br
.ti -1c
.RI "void \fBsetName\fP (const QString &name)"
.br
.ti -1c
.RI "void \fBsetAntialiasedFill\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetAntialiasedScatters\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &pen)"
.br
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &brush)"
.br
.ti -1c
.RI "void \fBsetKeyAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "void \fBsetValueAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelectable\fP (\fBQCP::SelectionType\fP selectable)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelection\fP (\fBQCPDataSelection\fP \fBselection\fP)"
.br
.ti -1c
.RI "void \fBsetSelectionDecorator\fP (\fBQCPSelectionDecorator\fP *decorator)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const =0"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP ()"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const =0"
.br
.ti -1c
.RI "void \fBcoordsToPixels\fP (double key, double value, double &x, double &y) const"
.br
.ti -1c
.RI "const QPointF \fBcoordsToPixels\fP (double key, double value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (double x, double y, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (const QPointF &pixelPos, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBrescaleAxes\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleKeyAxis\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleValueAxis\fP (bool onlyEnlarge=false, bool inKeyRange=false) const"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP (\fBQCPLegend\fP *legend)"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP ()"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP (\fBQCPLegend\fP *legend) const"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.in +1c
.ti -1c
.RI "virtual int \fBdataCount\fP () const =0"
.br
.ti -1c
.RI "virtual double \fBdataMainKey\fP (int index) const =0"
.br
.ti -1c
.RI "virtual double \fBdataSortKey\fP (int index) const =0"
.br
.ti -1c
.RI "virtual double \fBdataMainValue\fP (int index) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBdataValueRange\fP (int index) const =0"
.br
.ti -1c
.RI "virtual QPointF \fBdataPixelPosition\fP (int index) const =0"
.br
.ti -1c
.RI "virtual bool \fBsortKeyIsMainKey\fP () const =0"
.br
.ti -1c
.RI "virtual \fBQCPDataSelection\fP \fBselectTestRect\fP (const QRectF &rect, bool onlySelectable) const =0"
.br
.ti -1c
.RI "virtual int \fBfindBegin\fP (double sortKey, bool expandedRange=true) const =0"
.br
.ti -1c
.RI "virtual int \fBfindEnd\fP (double sortKey, bool expandedRange=true) const =0"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawCurveLine\fP (\fBQCPPainter\fP *painter, const QVector< QPointF > &lines) const"
.br
.ti -1c
.RI "virtual void \fBdrawScatterPlot\fP (\fBQCPPainter\fP *painter, const QVector< QPointF > &points, const \fBQCPScatterStyle\fP &style) const"
.br
.ti -1c
.RI "void \fBgetCurveLines\fP (QVector< QPointF > *lines, const \fBQCPDataRange\fP &dataRange, double penWidth) const"
.br
.ti -1c
.RI "void \fBgetScatters\fP (QVector< QPointF > *scatters, const \fBQCPDataRange\fP &dataRange, double scatterWidth) const"
.br
.ti -1c
.RI "int \fBgetRegion\fP (double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const"
.br
.ti -1c
.RI "QPointF \fBgetOptimizedPoint\fP (int prevRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const"
.br
.ti -1c
.RI "QVector< QPointF > \fBgetOptimizedCornerPoints\fP (int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const"
.br
.ti -1c
.RI "bool \fBmayTraverse\fP (int prevRegion, int currentRegion) const"
.br
.ti -1c
.RI "bool \fBgetTraverse\fP (double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF &crossA, QPointF &crossB) const"
.br
.ti -1c
.RI "void \fBgetTraverseCornerPoints\fP (int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, QVector< QPointF > &beforeTraverse, QVector< QPointF > &afterTraverse) const"
.br
.ti -1c
.RI "double \fBpointDistance\fP (const QPointF &pixelPoint, QCPCurveDataContainer::const_iterator &closestData) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPAbstractPlottable1D< QCPCurveData >\fP
.in +1c
.ti -1c
.RI "void \fBgetDataSegments\fP (QList< \fBQCPDataRange\fP > &selectedSegments, QList< \fBQCPDataRange\fP > &unselectedSegments) const"
.br
.ti -1c
.RI "void \fBdrawPolyline\fP (\fBQCPPainter\fP *painter, const QVector< QPointF > &lineData) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE=0"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const =0"
.br
.ti -1c
.RI "void \fBapplyFillAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.ti -1c
.RI "void \fBapplyScattersAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBQCPScatterStyle\fP \fBmScatterStyle\fP"
.br
.ti -1c
.RI "int \fBmScatterSkip\fP"
.br
.ti -1c
.RI "\fBLineStyle\fP \fBmLineStyle\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPAbstractPlottable1D< QCPCurveData >\fP
.in +1c
.ti -1c
.RI "QSharedPointer< \fBQCPDataContainer\fP< \fBQCPCurveData\fP > > \fBmDataContainer\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "QString \fBmName\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedFill\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedScatters\fP"
.br
.ti -1c
.RI "QPen \fBmPen\fP"
.br
.ti -1c
.RI "QBrush \fBmBrush\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmKeyAxis\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmValueAxis\fP"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBmSelectable\fP"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBmSelection\fP"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBmSelectionDecorator\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCustomPlot\fP"
.br
.ti -1c
.RI "class \fBQCPLegend\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Signals inherited from \fBQCPAbstractPlottable\fP
.in +1c
.ti -1c
.RI "void \fBselectionChanged\fP (bool \fBselected\fP)"
.br
.ti -1c
.RI "void \fBselectionChanged\fP (const \fBQCPDataSelection\fP &\fBselection\fP)"
.br
.ti -1c
.RI "void \fBselectableChanged\fP (\fBQCP::SelectionType\fP selectable)"
.br
.in -1c

Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A plottable representing a parametric curve in a plot\&. 


.PP
Unlike \fBQCPGraph\fP, plottables of this type may have multiple points with the same key coordinate, so their visual representation can have \fIloops\fP\&. This is realized by introducing a third coordinate \fIt\fP, which defines the order of the points described by the other two coordinates \fIx\fP and \fIy\fP\&.
.PP
To plot data, assign it with the \fBsetData\fP or \fBaddData\fP functions\&. Alternatively, you can also access and modify the curve's data via the \fBdata\fP method, which returns a pointer to the internal \fBQCPCurveDataContainer\fP\&.
.PP
Gaps in the curve can be created by adding data points with NaN as key and value (\fCqQNaN()\fP or \fCstd::numeric_limits<double>::quiet_NaN()\fP) in between the two data points that shall be separated\&.
.SH "Changing the appearance"
.PP
The appearance of the curve is determined by the pen and the brush (\fBsetPen\fP, \fBsetBrush\fP)\&.
.SH "Usage"
.PP
Like all data representing objects in \fBQCustomPlot\fP, the \fBQCPCurve\fP is a plottable (\fBQCPAbstractPlottable\fP)\&. So the plottable-interface of \fBQCustomPlot\fP applies (\fBQCustomPlot::plottable\fP, \fBQCustomPlot::removePlottable\fP, etc\&.)
.PP
Usually, you first create an instance: 
.PP
.nf

.fi
.PP
 which registers it with the \fBQCustomPlot\fP instance of the passed axes\&. Note that this \fBQCustomPlot\fP instance takes ownership of the plottable, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. The newly created plottable can be modified, e\&.g\&.: 
.PP
.nf

.fi
.PP
 
.PP
Definition at line \fB5292\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQCPCurve::LineStyle\fP"
Defines how the curve's line is represented visually in the plot\&. The line is drawn with the current pen of the curve (\fBsetPen\fP)\&. 
.PP
\fBSee also\fP
.RS 4
\fBsetLineStyle\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIlsNone \fP\fP
No line is drawn between data points (e\&.g\&. only scatters) 
.TP
\fB\fIlsLine \fP\fP
Data points are connected with a straight line\&. 
.PP
Definition at line \fB5306\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPCurve::QCPCurve (\fBQCPAxis\fP * keyAxis, \fBQCPAxis\fP * valueAxis)\fC [explicit]\fP"
Constructs a curve which uses \fIkeyAxis\fP as its key axis ('x') and \fIvalueAxis\fP as its value axis ('y')\&. \fIkeyAxis\fP and \fIvalueAxis\fP must reside in the same \fBQCustomPlot\fP instance and not have the same orientation\&. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though\&.
.PP
The created \fBQCPCurve\fP is automatically registered with the \fBQCustomPlot\fP instance inferred from \fIkeyAxis\fP\&. This \fBQCustomPlot\fP instance takes ownership of the \fBQCPCurve\fP, so do not delete it manually but use \fBQCustomPlot::removePlottable()\fP instead\&. 
.PP
Definition at line \fB21808\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPCurve::~QCPCurve ()\fC [virtual]\fP"

.PP
Definition at line \fB21820\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void QCPCurve::addData (const QVector< double > & keys, const QVector< double > & values)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the provided points in \fIkeys\fP and \fIvalues\fP to the current data\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
The t parameter of each data point will be set to the integer index of the respective key/value pair\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB21963\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::addData (const QVector< double > & t, const QVector< double > & keys, const QVector< double > & values, bool alreadySorted = \fCfalse\fP)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the provided points in \fIt\fP, \fIkeys\fP and \fIvalues\fP to the current data\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
If you can guarantee that the passed data points are sorted by \fIkeys\fP in ascending order, you can set \fIalreadySorted\fP to true, to improve performance by saving a sorting run\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB21931\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::addData (double key, double value)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the provided data point as \fIkey\fP and \fIvalue\fP to the current data\&.
.PP
The t parameter is generated automatically by increments of 1 for each point, starting at the highest t of previously existing data or 0, if the curve data is empty\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB22009\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::addData (double t, double key, double value)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. Adds the provided data point as \fIt\fP, \fIkey\fP and \fIvalue\fP to the current data\&.
.PP
Alternatively, you can also access and modify the data directly via the \fBdata\fP method, which returns a pointer to the internal data container\&. 
.PP
Definition at line \fB21994\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSharedPointer< \fBQCPCurveDataContainer\fP > QCPCurve::data () const\fC [inline]\fP"
Returns a shared pointer to the internal data storage of type \fBQCPCurveDataContainer\fP\&. You may use it to directly manipulate the data, which may be more convenient and faster than using the regular \fBsetData\fP or \fBaddData\fP methods\&. 
.PP
Definition at line \fB5315\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPCurve::draw (\fBQCPPainter\fP * painter)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB22052\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::drawCurveLine (\fBQCPPainter\fP * painter, const QVector< QPointF > & lines) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB22160\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::drawLegendIcon (\fBQCPPainter\fP * painter, const QRectF & rect) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB22120\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::drawScatterPlot (\fBQCPPainter\fP * painter, const QVector< QPointF > & points, const \fBQCPScatterStyle\fP & style) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB22176\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::getCurveLines (QVector< QPointF > * lines, const \fBQCPDataRange\fP & dataRange, double penWidth) const\fC [protected]\fP"

.PP
Definition at line \fB22214\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPCurve::getKeyRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP) const\fC [virtual]\fP"
Returns the coordinate range that all data in this plottable span in the key axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetValueRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB22040\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QVector< QPointF > QCPCurve::getOptimizedCornerPoints (int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\fC [protected]\fP"

.PP
Definition at line \fB22575\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QPointF QCPCurve::getOptimizedPoint (int prevRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\fC [protected]\fP"

.PP
Definition at line \fB22459\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPCurve::getRegion (double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const\fC [protected]\fP"

.PP
Definition at line \fB22415\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::getScatters (QVector< QPointF > * scatters, const \fBQCPDataRange\fP & dataRange, double scatterWidth) const\fC [protected]\fP"

.PP
Definition at line \fB22317\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPCurve::getTraverse (double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF & crossA, QPointF & crossB) const\fC [protected]\fP"

.PP
Definition at line \fB22842\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::getTraverseCornerPoints (int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, QVector< QPointF > & beforeTraverse, QVector< QPointF > & afterTraverse) const\fC [protected]\fP"

.PP
Definition at line \fB22955\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPRange\fP QCPCurve::getValueRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP, const \fBQCPRange\fP & inKeyRange = \fC\fBQCPRange\fP()\fP) const\fC [virtual]\fP"
Returns the coordinate range that the data points in the specified key range (\fIinKeyRange\fP) span in the value axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
If \fIinKeyRange\fP has both lower and upper bound set to zero (is equal to \fC\fBQCPRange()\fP\fP), all data points are considered, without any restriction on the keys\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetKeyRange\fP 
.RE
.PP

.PP
Implements \fBQCPAbstractPlottable\fP\&.
.PP
Definition at line \fB22046\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBLineStyle\fP QCPCurve::lineStyle () const\fC [inline]\fP"

.PP
Definition at line \fB5318\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPCurve::mayTraverse (int prevRegion, int currentRegion) const\fC [protected]\fP"

.PP
Definition at line \fB22739\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPCurve::pointDistance (const QPointF & pixelPoint, QCPCurveDataContainer::const_iterator & closestData) const\fC [protected]\fP"

.PP
Definition at line \fB23051\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPCurve::scatterSkip () const\fC [inline]\fP"

.PP
Definition at line \fB5317\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPScatterStyle\fP QCPCurve::scatterStyle () const\fC [inline]\fP"

.PP
Definition at line \fB5316\fP of file \fBqcustomplot\&.h\fP\&.
.SS "double QCPCurve::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [virtual]\fP"
Implements a point-selection algorithm assuming the data (accessed via the 1D data interface) is point-like\&. Most subclasses will want to reimplement this method again, to provide a more accurate hit test based on the true data visualization geometry\&.
.PP
\\seebaseclassmethod 
.PP
Reimplemented from \fBQCPAbstractPlottable1D< QCPCurveData >\fP\&.
.PP
Definition at line \fB22018\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setData (const QVector< double > & keys, const QVector< double > & values)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data with the provided points in \fIkeys\fP and \fIvalues\fP\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
The t parameter of each data point will be set to the integer index of the respective key/value pair\&.
.PP
\fBSee also\fP
.RS 4
\fBaddData\fP 
.RE
.PP

.PP
Definition at line \fB21873\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setData (const QVector< double > & t, const QVector< double > & keys, const QVector< double > & values, bool alreadySorted = \fCfalse\fP)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data with the provided points in \fIt\fP, \fIkeys\fP and \fIvalues\fP\&. The provided vectors should have equal length\&. Else, the number of added points will be the size of the smallest vector\&.
.PP
If you can guarantee that the passed data points are sorted by \fIt\fP in ascending order, you can set \fIalreadySorted\fP to true, to improve performance by saving a sorting run\&.
.PP
\fBSee also\fP
.RS 4
\fBaddData\fP 
.RE
.PP

.PP
Definition at line \fB21855\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setData (QSharedPointer< \fBQCPCurveDataContainer\fP > data)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Replaces the current data container with the provided \fIdata\fP container\&.
.PP
Since a QSharedPointer is used, multiple QCPCurves may share the same data container safely\&. Modifying the data in the container will then affect all curves that share the container\&. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: 
.PP
.nf

.fi
.PP
.PP
If you do not wish to share containers, but create a copy from an existing container, rather use the \fBQCPDataContainer<DataType>::set\fP method on the curve's data container directly: 
.PP
.nf

.fi
.PP
.PP
\fBSee also\fP
.RS 4
\fBaddData\fP 
.RE
.PP

.PP
Definition at line \fB21839\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setLineStyle (\fBQCPCurve::LineStyle\fP style)"
Sets how the single data points are connected in the plot or how they are represented visually apart from the scatter symbol\&. For scatter-only plots, set \fIstyle\fP to \fBlsNone\fP and \fBsetScatterStyle\fP to the desired scatter style\&.
.PP
\fBSee also\fP
.RS 4
\fBsetScatterStyle\fP 
.RE
.PP

.PP
Definition at line \fB21914\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setScatterSkip (int skip)"
If scatters are displayed (scatter style not \fBQCPScatterStyle::ssNone\fP), \fIskip\fP number of scatter points are skipped/not drawn after every drawn scatter point\&.
.PP
This can be used to make the data appear sparser while for example still having a smooth line, and to improve performance for very high density plots\&.
.PP
If \fIskip\fP is set to 0 (default), all scatter points are drawn\&.
.PP
\fBSee also\fP
.RS 4
\fBsetScatterStyle\fP 
.RE
.PP

.PP
Definition at line \fB21902\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPCurve::setScatterStyle (const \fBQCPScatterStyle\fP & style)"
Sets the visual appearance of single data points in the plot\&. If set to \fBQCPScatterStyle::ssNone\fP, no scatter points are drawn (e\&.g\&. for line-only plots with appropriate line style)\&.
.PP
\fBSee also\fP
.RS 4
\fBQCPScatterStyle\fP, \fBsetLineStyle\fP 
.RE
.PP

.PP
Definition at line \fB21886\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBQCPLegend\fP\fC [friend]\fP"

.PP
Definition at line \fB5365\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCustomPlot\fP\fC [friend]\fP"

.PP
Definition at line \fB5364\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBLineStyle\fP QCPCurve::mLineStyle\fC [protected]\fP"

.PP
Definition at line \fB5343\fP of file \fBqcustomplot\&.h\fP\&.
.SS "int QCPCurve::mScatterSkip\fC [protected]\fP"

.PP
Definition at line \fB5342\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPScatterStyle\fP QCPCurve::mScatterStyle\fC [protected]\fP"

.PP
Definition at line \fB5341\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
