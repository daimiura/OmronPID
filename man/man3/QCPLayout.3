.TH "QCPLayout" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPLayout \- The abstract base class for layouts\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPLayoutElement\fP\&.
.PP
Inherited by \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPLayout\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBelementCount\fP () const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBelementAt\fP (int index) const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBtakeAt\fP (int index)=0"
.br
.ti -1c
.RI "virtual bool \fBtake\fP (\fBQCPLayoutElement\fP *element)=0"
.br
.ti -1c
.RI "virtual void \fBsimplify\fP ()"
.br
.ti -1c
.RI "bool \fBremoveAt\fP (int index)"
.br
.ti -1c
.RI "bool \fBremove\fP (\fBQCPLayoutElement\fP *element)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayoutElement\fP (\fBQCustomPlot\fP *parentPlot=0)"
.br
.ti -1c
.RI "\fBQCPLayout\fP * \fBlayout\fP () const"
.br
.ti -1c
.RI "QRect \fBrect\fP () const"
.br
.ti -1c
.RI "QRect \fBouterRect\fP () const"
.br
.ti -1c
.RI "QMargins \fBmargins\fP () const"
.br
.ti -1c
.RI "QMargins \fBminimumMargins\fP () const"
.br
.ti -1c
.RI "QCP::MarginSides \fBautoMargins\fP () const"
.br
.ti -1c
.RI "QSize \fBminimumSize\fP () const"
.br
.ti -1c
.RI "QSize \fBmaximumSize\fP () const"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBsizeConstraintRect\fP () const"
.br
.ti -1c
.RI "\fBQCPMarginGroup\fP * \fBmarginGroup\fP (\fBQCP::MarginSide\fP side) const"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmarginGroups\fP () const"
.br
.ti -1c
.RI "void \fBsetOuterRect\fP (const QRect &\fBrect\fP)"
.br
.ti -1c
.RI "void \fBsetMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetMinimumMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetAutoMargins\fP (QCP::MarginSides sides)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetSizeConstraintRect\fP (\fBSizeConstraintRect\fP constraintRect)"
.br
.ti -1c
.RI "void \fBsetMarginGroup\fP (QCP::MarginSides sides, \fBQCPMarginGroup\fP *group)"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase)"
.br
.ti -1c
.RI "virtual QSize \fBminimumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QSize \fBmaximumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBsizeConstraintsChanged\fP () const"
.br
.ti -1c
.RI "void \fBadoptElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "void \fBreleaseElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "QVector< int > \fBgetSectionSizes\fP (QVector< int > maxSizes, QVector< int > minSizes, QVector< double > stretchFactors, int totalSize) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "virtual int \fBcalculateAutoMargin\fP (\fBQCP::MarginSide\fP side)"
.br
.ti -1c
.RI "virtual void \fBlayoutChanged\fP ()"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot) Q_DECL_OVERRIDE"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static QSize \fBgetFinalMinimumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "static QSize \fBgetFinalMaximumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCPLayoutElement\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "enum \fBUpdatePhase\fP { \fBupPreparation\fP, \fBupMargins\fP, \fBupLayout\fP }"
.br
.ti -1c
.RI "enum \fBSizeConstraintRect\fP { \fBscrInnerRect\fP, \fBscrOuterRect\fP }"
.br
.in -1c

Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayout\fP * \fBmParentLayout\fP"
.br
.ti -1c
.RI "QSize \fBmMinimumSize\fP"
.br
.ti -1c
.RI "QSize \fBmMaximumSize\fP"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBmSizeConstraintRect\fP"
.br
.ti -1c
.RI "QRect \fBmRect\fP"
.br
.ti -1c
.RI "QRect \fBmOuterRect\fP"
.br
.ti -1c
.RI "QMargins \fBmMargins\fP"
.br
.ti -1c
.RI "QMargins \fBmMinimumMargins\fP"
.br
.ti -1c
.RI "QCP::MarginSides \fBmAutoMargins\fP"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmMarginGroups\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The abstract base class for layouts\&. 

This is an abstract base class for layout elements whose main purpose is to define the position and size of other child layout elements\&. In most cases, layouts don't draw anything themselves (but there are exceptions to this, e\&.g\&. \fBQCPLegend\fP)\&.
.PP
\fBQCPLayout\fP derives from \fBQCPLayoutElement\fP, and thus can itself be nested in other layouts\&.
.PP
\fBQCPLayout\fP introduces a common interface for accessing and manipulating the child elements\&. Those functions are most notably \fBelementCount\fP, \fBelementAt\fP, \fBtakeAt\fP, \fBtake\fP, \fBsimplify\fP, \fBremoveAt\fP, \fBremove\fP and \fBclear\fP\&. Individual subclasses may add more functions to this interface which are more specialized to the form of the layout\&. For example, \fBQCPLayoutGrid\fP adds functions that take row and column indices to access cells of the layout grid more conveniently\&.
.PP
Since this is an abstract base class, you can't instantiate it directly\&. Rather use one of its subclasses like \fBQCPLayoutGrid\fP or \fBQCPLayoutInset\fP\&.
.PP
For a general introduction to the layout system, see the dedicated documentation page \fBThe Layout System\fP\&. 
.PP
Definition at line \fB1282\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPLayout::QCPLayout ()\fC [explicit]\fP"
Creates an instance of \fBQCPLayout\fP and sets default values\&. Note that since \fBQCPLayout\fP is an abstract base class, it can't be instantiated directly\&. 
.PP
Definition at line \fB3634\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void QCPLayout::adoptElement (\fBQCPLayoutElement\fP * el)\fC [protected]\fP"

.PP
Definition at line \fB3799\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayout::clear ()"
Removes and deletes all layout elements in this layout\&. Finally calls \fBsimplify\fP to make sure all empty cells are collapsed\&.
.PP
\fBSee also\fP
.RS 4
\fBremove\fP, \fBremoveAt\fP 
.RE
.PP

.PP
Definition at line \fB3744\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayout::elementAt (int index) const\fC [pure virtual]\fP"
Returns the element in the cell with the given \fIindex\fP\&. If \fIindex\fP is invalid, returns 0\&.
.PP
Note that even if \fIindex\fP is valid, the respective cell may be empty in some layouts (e\&.g\&. \fBQCPLayoutGrid\fP), so this function may return 0 in those cases\&. You may use this function to check whether a cell is empty or not\&.
.PP
\fBSee also\fP
.RS 4
\fBelements\fP, \fBelementCount\fP, \fBtakeAt\fP 
.RE
.PP

.PP
Implemented in \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.SS "int QCPLayout::elementCount () const\fC [pure virtual]\fP"
Returns the number of elements/cells in the layout\&.
.PP
\fBSee also\fP
.RS 4
\fBelements\fP, \fBelementAt\fP 
.RE
.PP

.PP
Implemented in \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.SS "QList< \fBQCPLayoutElement\fP * > QCPLayout::elements (bool recursive) const\fC [virtual]\fP"
Returns a list of all child elements in this layout element\&. If \fIrecursive\fP is true, all sub-child elements are included in the list, too\&.
.PP
\fBWarning\fP
.RS 4
There may be entries with value 0 in the returned list\&. (For example, \fBQCPLayoutGrid\fP may have empty cells which yield 0 at the respective index\&.) 
.RE
.PP

.PP
Reimplemented from \fBQCPLayoutElement\fP\&.
.PP
Reimplemented in \fBQCPLayoutGrid\fP\&.
.PP
Definition at line \fB3665\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSize QCPLayout::getFinalMaximumOuterSize (const \fBQCPLayoutElement\fP * el)\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line \fB4014\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSize QCPLayout::getFinalMinimumOuterSize (const \fBQCPLayoutElement\fP * el)\fC [static]\fP, \fC [protected]\fP"

.PP
Definition at line \fB3989\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QVector< int > QCPLayout::getSectionSizes (QVector< int > maxSizes, QVector< int > minSizes, QVector< double > stretchFactors, int totalSize) const\fC [protected]\fP"

.PP
Definition at line \fB3864\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayout::releaseElement (\fBQCPLayoutElement\fP * el)\fC [protected]\fP"

.PP
Definition at line \fB3823\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayout::remove (\fBQCPLayoutElement\fP * element)"
Removes and deletes the provided \fIelement\fP\&. Returns true on success\&. If \fIelement\fP is not in the layout, returns false\&.
.PP
This function internally uses \fBtakeAt\fP to remove the element from the layout and then deletes the element\&. Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBremoveAt\fP, \fBtake\fP 
.RE
.PP

.PP
Definition at line \fB3728\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayout::removeAt (int index)"
Removes and deletes the element at the provided \fIindex\fP\&. Returns true on success\&. If \fIindex\fP is invalid or points to an empty cell, returns false\&.
.PP
This function internally uses \fBtakeAt\fP to remove the element from the layout and then deletes the returned element\&. Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBremove\fP, \fBtakeAt\fP 
.RE
.PP

.PP
Definition at line \fB3707\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayout::simplify ()\fC [virtual]\fP"
Simplifies the layout by collapsing empty cells\&. The exact behavior depends on subclasses, the default implementation does nothing\&.
.PP
Not all layouts need simplification\&. For example, \fBQCPLayoutInset\fP doesn't use explicit simplification while \fBQCPLayoutGrid\fP does\&. 
.PP
Reimplemented in \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.PP
Definition at line \fB3692\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayout::sizeConstraintsChanged () const\fC [protected]\fP"
Subclasses call this method to report changed (minimum/maximum) size constraints\&.
.PP
If the parent of this layout is again a \fBQCPLayout\fP, forwards the call to the parent's \fBsizeConstraintsChanged\fP\&. If the parent is a QWidget (i\&.e\&. is the \fBQCustomPlot::plotLayout\fP of \fBQCustomPlot\fP), calls QWidget::updateGeometry, so if the \fBQCustomPlot\fP widget is inside a Qt QLayout, it may update itself and resize cells accordingly\&. 
.PP
Definition at line \fB3762\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayout::take (\fBQCPLayoutElement\fP * element)\fC [pure virtual]\fP"
Removes the specified \fIelement\fP from the layout and returns true on success\&.
.PP
If the \fIelement\fP isn't in this layout, returns false\&.
.PP
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBtakeAt\fP 
.RE
.PP

.PP
Implemented in \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayout::takeAt (int index)\fC [pure virtual]\fP"
Removes the element with the given \fIindex\fP from the layout and returns it\&.
.PP
If the \fIindex\fP is invalid or the cell with that index is empty, returns 0\&.
.PP
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBelementAt\fP, \fBtake\fP 
.RE
.PP

.PP
Implemented in \fBQCPLayoutGrid\fP, and \fBQCPLayoutInset\fP\&.
.SS "void QCPLayout::update (\fBUpdatePhase\fP phase)\fC [virtual]\fP"
If \fIphase\fP is \fBupLayout\fP, calls \fBupdateLayout\fP, which subclasses may reimplement to reposition and resize their cells\&.
.PP
Finally, the call is propagated down to all child \fBQCPLayoutElements\fP\&.
.PP
For details about this method and the update phases, see the documentation of \fBQCPLayoutElement::update\fP\&. 
.PP
Reimplemented from \fBQCPLayoutElement\fP\&.
.PP
Definition at line \fB3647\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayout::updateLayout ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB3782\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBQCPLayoutElement\fP\fC [friend]\fP"

.PP
Definition at line \fB1318\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
