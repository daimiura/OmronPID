.TH "QCPLayoutGrid" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPLayoutGrid \- A layout that arranges child elements in a grid\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPLayout\fP\&.
.PP
Inherited by \fBQCPLegend\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBFillOrder\fP { \fBfoRowsFirst\fP, \fBfoColumnsFirst\fP }"
.br
.in -1c

Public Types inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "enum \fBUpdatePhase\fP { \fBupPreparation\fP, \fBupMargins\fP, \fBupLayout\fP }"
.br
.ti -1c
.RI "enum \fBSizeConstraintRect\fP { \fBscrInnerRect\fP, \fBscrOuterRect\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPLayoutGrid\fP ()"
.br
.ti -1c
.RI "int \fBrowCount\fP () const"
.br
.ti -1c
.RI "int \fBcolumnCount\fP () const"
.br
.ti -1c
.RI "QList< double > \fBcolumnStretchFactors\fP () const"
.br
.ti -1c
.RI "QList< double > \fBrowStretchFactors\fP () const"
.br
.ti -1c
.RI "int \fBcolumnSpacing\fP () const"
.br
.ti -1c
.RI "int \fBrowSpacing\fP () const"
.br
.ti -1c
.RI "int \fBwrap\fP () const"
.br
.ti -1c
.RI "\fBFillOrder\fP \fBfillOrder\fP () const"
.br
.ti -1c
.RI "void \fBsetColumnStretchFactor\fP (int column, double factor)"
.br
.ti -1c
.RI "void \fBsetColumnStretchFactors\fP (const QList< double > &factors)"
.br
.ti -1c
.RI "void \fBsetRowStretchFactor\fP (int row, double factor)"
.br
.ti -1c
.RI "void \fBsetRowStretchFactors\fP (const QList< double > &factors)"
.br
.ti -1c
.RI "void \fBsetColumnSpacing\fP (int pixels)"
.br
.ti -1c
.RI "void \fBsetRowSpacing\fP (int pixels)"
.br
.ti -1c
.RI "void \fBsetWrap\fP (int count)"
.br
.ti -1c
.RI "void \fBsetFillOrder\fP (\fBFillOrder\fP order, bool rearrange=true)"
.br
.ti -1c
.RI "virtual void \fBupdateLayout\fP () Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBelementCount\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBelementAt\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBtakeAt\fP (int index) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual bool \fBtake\fP (\fBQCPLayoutElement\fP *\fBelement\fP) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBsimplify\fP () Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QSize \fBminimumOuterSizeHint\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QSize \fBmaximumOuterSizeHint\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "\fBQCPLayoutElement\fP * \fBelement\fP (int row, int column) const"
.br
.ti -1c
.RI "bool \fBaddElement\fP (int row, int column, \fBQCPLayoutElement\fP *\fBelement\fP)"
.br
.ti -1c
.RI "bool \fBaddElement\fP (\fBQCPLayoutElement\fP *\fBelement\fP)"
.br
.ti -1c
.RI "bool \fBhasElement\fP (int row, int column)"
.br
.ti -1c
.RI "void \fBexpandTo\fP (int newRowCount, int newColumnCount)"
.br
.ti -1c
.RI "void \fBinsertRow\fP (int newIndex)"
.br
.ti -1c
.RI "void \fBinsertColumn\fP (int newIndex)"
.br
.ti -1c
.RI "int \fBrowColToIndex\fP (int row, int column) const"
.br
.ti -1c
.RI "void \fBindexToRowCol\fP (int index, int &row, int &column) const"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "\fBQCPLayout\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBelementCount\fP () const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBelementAt\fP (int index) const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBtakeAt\fP (int index)=0"
.br
.ti -1c
.RI "virtual bool \fBtake\fP (\fBQCPLayoutElement\fP *element)=0"
.br
.ti -1c
.RI "virtual void \fBsimplify\fP ()"
.br
.ti -1c
.RI "bool \fBremoveAt\fP (int index)"
.br
.ti -1c
.RI "bool \fBremove\fP (\fBQCPLayoutElement\fP *element)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayoutElement\fP (\fBQCustomPlot\fP *parentPlot=0)"
.br
.ti -1c
.RI "\fBQCPLayout\fP * \fBlayout\fP () const"
.br
.ti -1c
.RI "QRect \fBrect\fP () const"
.br
.ti -1c
.RI "QRect \fBouterRect\fP () const"
.br
.ti -1c
.RI "QMargins \fBmargins\fP () const"
.br
.ti -1c
.RI "QMargins \fBminimumMargins\fP () const"
.br
.ti -1c
.RI "QCP::MarginSides \fBautoMargins\fP () const"
.br
.ti -1c
.RI "QSize \fBminimumSize\fP () const"
.br
.ti -1c
.RI "QSize \fBmaximumSize\fP () const"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBsizeConstraintRect\fP () const"
.br
.ti -1c
.RI "\fBQCPMarginGroup\fP * \fBmarginGroup\fP (\fBQCP::MarginSide\fP side) const"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmarginGroups\fP () const"
.br
.ti -1c
.RI "void \fBsetOuterRect\fP (const QRect &\fBrect\fP)"
.br
.ti -1c
.RI "void \fBsetMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetMinimumMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetAutoMargins\fP (QCP::MarginSides sides)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetSizeConstraintRect\fP (\fBSizeConstraintRect\fP constraintRect)"
.br
.ti -1c
.RI "void \fBsetMarginGroup\fP (QCP::MarginSides sides, \fBQCPMarginGroup\fP *group)"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase)"
.br
.ti -1c
.RI "virtual QSize \fBminimumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QSize \fBmaximumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBgetMinimumRowColSizes\fP (QVector< int > *minColWidths, QVector< int > *minRowHeights) const"
.br
.ti -1c
.RI "void \fBgetMaximumRowColSizes\fP (QVector< int > *maxColWidths, QVector< int > *maxRowHeights) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "virtual void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBsizeConstraintsChanged\fP () const"
.br
.ti -1c
.RI "void \fBadoptElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "void \fBreleaseElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "QVector< int > \fBgetSectionSizes\fP (QVector< int > maxSizes, QVector< int > minSizes, QVector< double > stretchFactors, int totalSize) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "virtual int \fBcalculateAutoMargin\fP (\fBQCP::MarginSide\fP side)"
.br
.ti -1c
.RI "virtual void \fBlayoutChanged\fP ()"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot) Q_DECL_OVERRIDE"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "QList< QList< \fBQCPLayoutElement\fP * > > \fBmElements\fP"
.br
.ti -1c
.RI "QList< double > \fBmColumnStretchFactors\fP"
.br
.ti -1c
.RI "QList< double > \fBmRowStretchFactors\fP"
.br
.ti -1c
.RI "int \fBmColumnSpacing\fP"
.br
.ti -1c
.RI "int \fBmRowSpacing\fP"
.br
.ti -1c
.RI "int \fBmWrap\fP"
.br
.ti -1c
.RI "\fBFillOrder\fP \fBmFillOrder\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayout\fP * \fBmParentLayout\fP"
.br
.ti -1c
.RI "QSize \fBmMinimumSize\fP"
.br
.ti -1c
.RI "QSize \fBmMaximumSize\fP"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBmSizeConstraintRect\fP"
.br
.ti -1c
.RI "QRect \fBmRect\fP"
.br
.ti -1c
.RI "QRect \fBmOuterRect\fP"
.br
.ti -1c
.RI "QMargins \fBmMargins\fP"
.br
.ti -1c
.RI "QMargins \fBmMinimumMargins\fP"
.br
.ti -1c
.RI "QCP::MarginSides \fBmAutoMargins\fP"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmMarginGroups\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c

Static Protected Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "static QSize \fBgetFinalMinimumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "static QSize \fBgetFinalMaximumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A layout that arranges child elements in a grid\&. 

Elements are laid out in a grid with configurable stretch factors (\fBsetColumnStretchFactor\fP, \fBsetRowStretchFactor\fP) and spacing (\fBsetColumnSpacing\fP, \fBsetRowSpacing\fP)\&.
.PP
Elements can be added to cells via \fBaddElement\fP\&. The grid is expanded if the specified row or column doesn't exist yet\&. Whether a cell contains a valid layout element can be checked with \fBhasElement\fP, that element can be retrieved with \fBelement\fP\&. If rows and columns that only have empty cells shall be removed, call \fBsimplify\fP\&. Removal of elements is either done by just adding the element to a different layout or by using the \fBQCPLayout\fP interface \fBtake\fP or \fBremove\fP\&.
.PP
If you use \fBaddElement(QCPLayoutElement*)\fP without explicit parameters for \fIrow\fP and \fIcolumn\fP, the grid layout will choose the position according to the current \fBsetFillOrder\fP and the wrapping (\fBsetWrap\fP)\&.
.PP
Row and column insertion can be performed with \fBinsertRow\fP and \fBinsertColumn\fP\&. 
.PP
Definition at line \fB1322\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQCPLayoutGrid::FillOrder\fP"
Defines in which direction the grid is filled when using \fBaddElement(QCPLayoutElement*)\fP\&. The column/row at which wrapping into the next row/column occurs can be specified with \fBsetWrap\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBsetFillOrder\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIfoRowsFirst \fP\fP
Rows are filled first, and a new element is wrapped to the next column if the row count would exceed \fBsetWrap\fP\&. 
.TP
\fB\fIfoColumnsFirst \fP\fP
Columns are filled first, and a new element is wrapped to the next row if the column count would exceed \fBsetWrap\fP\&. 
.PP
Definition at line \fB1344\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPLayoutGrid::QCPLayoutGrid ()\fC [explicit]\fP"
Creates an instance of \fBQCPLayoutGrid\fP and sets default values\&. 
.PP
Definition at line \fB4073\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPLayoutGrid::~QCPLayoutGrid ()\fC [virtual]\fP"

.PP
Definition at line \fB4081\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "bool QCPLayoutGrid::addElement (int row, int column, \fBQCPLayoutElement\fP * element)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the \fIelement\fP to cell with \fIrow\fP and \fIcolumn\fP\&. If \fIelement\fP is already in a layout, it is first removed from there\&. If \fIrow\fP or \fIcolumn\fP don't exist yet, the layout is expanded accordingly\&.
.PP
Returns true if the element was added successfully, i\&.e\&. if the cell at \fIrow\fP and \fIcolumn\fP didn't already have an element\&.
.PP
Use the overload of this method without explicit row/column index to place the element according to the configured fill order and wrapping settings\&.
.PP
\fBSee also\fP
.RS 4
\fBelement\fP, \fBhasElement\fP, \fBtake\fP, \fBremove\fP 
.RE
.PP

.PP
Definition at line \fB4128\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayoutGrid::addElement (\fBQCPLayoutElement\fP * element)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds the \fIelement\fP to the next empty cell according to the current fill order (\fBsetFillOrder\fP) and wrapping (\fBsetWrap\fP)\&. If \fIelement\fP is already in a layout, it is first removed from there\&. If necessary, the layout is expanded to hold the new element\&.
.PP
Returns true if the element was added successfully\&.
.PP
\fBSee also\fP
.RS 4
\fBsetFillOrder\fP, \fBsetWrap\fP, \fBelement\fP, \fBhasElement\fP, \fBtake\fP, \fBremove\fP 
.RE
.PP

.PP
Definition at line \fB4154\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPLayoutGrid::columnCount () const\fC [inline]\fP"
Returns the number of columns in the layout\&.
.PP
\fBSee also\fP
.RS 4
\fBrowCount\fP 
.RE
.PP

.PP
Definition at line \fB1354\fP of file \fBqcustomplot\&.h\fP\&.
.SS "int QCPLayoutGrid::columnSpacing () const\fC [inline]\fP"

.PP
Definition at line \fB1357\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList< double > QCPLayoutGrid::columnStretchFactors () const\fC [inline]\fP"

.PP
Definition at line \fB1355\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayoutGrid::element (int row, int column) const"
Returns the element in the cell in \fIrow\fP and \fIcolumn\fP\&.
.PP
Returns 0 if either the row/column is invalid or if the cell is empty\&. In those cases, a qDebug message is printed\&. To check whether a cell exists and isn't empty, use \fBhasElement\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBaddElement\fP, \fBhasElement\fP 
.RE
.PP

.PP
Definition at line \fB4096\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayoutGrid::elementAt (int index) const\fC [virtual]\fP"
\\seebaseclassmethod
.PP
Note that the association of the linear \fIindex\fP to the row/column based cells depends on the current setting of \fBsetFillOrder\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrowColToIndex\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB4593\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "virtual int QCPLayoutGrid::elementCount () const\fC [inline]\fP, \fC [virtual]\fP"
Returns the number of elements/cells in the layout\&.
.PP
\fBSee also\fP
.RS 4
\fBelements\fP, \fBelementAt\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB1374\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList< \fBQCPLayoutElement\fP * > QCPLayoutGrid::elements (bool recursive) const\fC [virtual]\fP"
Returns a list of all child elements in this layout element\&. If \fIrecursive\fP is true, all sub-child elements are included in the list, too\&.
.PP
\fBWarning\fP
.RS 4
There may be entries with value 0 in the returned list\&. (For example, \fBQCPLayoutGrid\fP may have empty cells which yield 0 at the respective index\&.) 
.RE
.PP

.PP
Reimplemented from \fBQCPLayout\fP\&.
.PP
Definition at line \fB4648\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::expandTo (int newRowCount, int newColumnCount)"
Expands the layout to have \fInewRowCount\fP rows and \fInewColumnCount\fP columns\&. So the last valid row index will be \fInewRowCount-1\fP, the last valid column index will be \fInewColumnCount-1\fP\&.
.PP
If the current column/row count is already larger or equal to \fInewColumnCount/\fInewRowCount\fP,\fP this function does nothing in that dimension\&.
.PP
Newly created cells are empty, new rows and columns have the stretch factor 1\&.
.PP
Note that upon a call to \fBaddElement\fP, the layout is expanded automatically to contain the specified row and column, using this function\&.
.PP
\fBSee also\fP
.RS 4
\fBsimplify\fP 
.RE
.PP

.PP
Definition at line \fB4409\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBFillOrder\fP QCPLayoutGrid::fillOrder () const\fC [inline]\fP"

.PP
Definition at line \fB1360\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPLayoutGrid::getMaximumRowColSizes (QVector< int > * maxColWidths, QVector< int > * maxRowHeights) const\fC [protected]\fP"

.PP
Definition at line \fB4800\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::getMinimumRowColSizes (QVector< int > * minColWidths, QVector< int > * minRowHeights) const\fC [protected]\fP"

.PP
Definition at line \fB4767\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayoutGrid::hasElement (int row, int column)"
Returns whether the cell at \fIrow\fP and \fIcolumn\fP exists and contains a valid element, i\&.e\&. isn't empty\&.
.PP
\fBSee also\fP
.RS 4
\fBelement\fP 
.RE
.PP

.PP
Definition at line \fB4190\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::indexToRowCol (int index, int & row, int & column) const"
Converts the linear index to row and column indices and writes the result to \fIrow\fP and \fIcolumn\fP\&.
.PP
The way the cells are indexed depends on \fBsetFillOrder\fP\&. If it is \fBfoRowsFirst\fP, the indices increase left to right and then top to bottom\&. If it is \fBfoColumnsFirst\fP, the indices increase top to bottom and then left to right\&.
.PP
If there are no cells (i\&.e\&. column or row count is zero), sets \fIrow\fP and \fIcolumn\fP to -1\&.
.PP
For the retrieved \fIrow\fP and \fIcolumn\fP to be valid, the passed \fIindex\fP must be valid itself, i\&.e\&. greater or equal to zero and smaller than the current \fBelementCount\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrowColToIndex\fP 
.RE
.PP

.PP
Definition at line \fB4525\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::insertColumn (int newIndex)"
Inserts a new column with empty cells at the column index \fInewIndex\fP\&. Valid values for \fInewIndex\fP range from 0 (inserts a column at the left) to \fIcolumnCount\fP (appends a column at the right)\&.
.PP
\fBSee also\fP
.RS 4
\fBinsertRow\fP 
.RE
.PP

.PP
Definition at line \fB4461\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::insertRow (int newIndex)"
Inserts a new row with empty cells at the row index \fInewIndex\fP\&. Valid values for \fInewIndex\fP range from 0 (inserts a row at the top) to \fIrowCount\fP (appends a row at the bottom)\&.
.PP
\fBSee also\fP
.RS 4
\fBinsertColumn\fP 
.RE
.PP

.PP
Definition at line \fB4434\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSize QCPLayoutGrid::maximumOuterSizeHint () const\fC [virtual]\fP"
Returns the suggested maximum size this layout element (the \fBouterRect\fP) may be expanded to, if no manual maximum size is set\&.
.PP
if a maximum size (\fBsetMaximumSize\fP) was not set manually, parent layouts use the returned size (usually indirectly through \fBQCPLayout::getFinalMaximumOuterSize\fP) to determine the maximum allowed size of this layout element\&.
.PP
A manual maximum size is considered set if it is smaller than Qt's \fCQWIDGETSIZE_MAX\fP\&.
.PP
The default implementation simply returns \fCQWIDGETSIZE_MAX\fP for both width and height, implying no suggested maximum size\&. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints\&. 
.PP
Reimplemented from \fBQCPLayoutElement\fP\&.
.PP
Definition at line \fB4733\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QSize QCPLayoutGrid::minimumOuterSizeHint () const\fC [virtual]\fP"
Returns the suggested minimum size this layout element (the \fBouterRect\fP) may be compressed to, if no manual minimum size is set\&.
.PP
if a minimum size (\fBsetMinimumSize\fP) was not set manually, parent layouts use the returned size (usually indirectly through \fBQCPLayout::getFinalMinimumOuterSize\fP) to determine the minimum allowed size of this layout element\&.
.PP
A manual minimum size is considered set if it is non-zero\&.
.PP
The default implementation simply returns the sum of the horizontal margins for the width and the sum of the vertical margins for the height\&. Reimplementations may use their detailed knowledge about the layout element's content to provide size hints\&. 
.PP
Reimplemented from \fBQCPLayoutElement\fP\&.
.PP
Definition at line \fB4716\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPLayoutGrid::rowColToIndex (int row, int column) const"
Converts the given \fIrow\fP and \fIcolumn\fP to the linear index used by some methods of \fBQCPLayoutGrid\fP and \fBQCPLayout\fP\&.
.PP
The way the cells are indexed depends on \fBsetFillOrder\fP\&. If it is \fBfoRowsFirst\fP, the indices increase left to right and then top to bottom\&. If it is \fBfoColumnsFirst\fP, the indices increase top to bottom and then left to right\&.
.PP
For the returned index to be valid, \fIrow\fP and \fIcolumn\fP must be valid indices themselves, i\&.e\&. greater or equal to zero and smaller than the current \fBrowCount/\fP columnCount\&.
.PP
\fBSee also\fP
.RS 4
\fBindexToRowCol\fP 
.RE
.PP

.PP
Definition at line \fB4492\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPLayoutGrid::rowCount () const\fC [inline]\fP"
Returns the number of rows in the layout\&.
.PP
\fBSee also\fP
.RS 4
\fBcolumnCount\fP 
.RE
.PP

.PP
Definition at line \fB1353\fP of file \fBqcustomplot\&.h\fP\&.
.SS "int QCPLayoutGrid::rowSpacing () const\fC [inline]\fP"

.PP
Definition at line \fB1358\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList< double > QCPLayoutGrid::rowStretchFactors () const\fC [inline]\fP"

.PP
Definition at line \fB1356\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPLayoutGrid::setColumnSpacing (int pixels)"
Sets the gap that is left blank between columns to \fIpixels\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBsetRowSpacing\fP 
.RE
.PP

.PP
Definition at line \fB4309\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setColumnStretchFactor (int column, double factor)"
Sets the stretch \fIfactor\fP of \fIcolumn\fP\&.
.PP
Stretch factors control the relative sizes of rows and columns\&. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor\&. (see \fBQCPLayoutElement::setMinimumSize\fP, \fBQCPLayoutElement::setMaximumSize\fP, \fBQCPLayoutElement::setSizeConstraintRect\fP\&.)
.PP
The default stretch factor of newly created rows/columns is 1\&.
.PP
\fBSee also\fP
.RS 4
\fBsetColumnStretchFactors\fP, \fBsetRowStretchFactor\fP 
.RE
.PP

.PP
Definition at line \fB4210\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setColumnStretchFactors (const QList< double > & factors)"
Sets the stretch \fIfactors\fP of all columns\&. \fIfactors\fP must have the size \fBcolumnCount\fP\&.
.PP
Stretch factors control the relative sizes of rows and columns\&. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor\&. (see \fBQCPLayoutElement::setMinimumSize\fP, \fBQCPLayoutElement::setMaximumSize\fP, \fBQCPLayoutElement::setSizeConstraintRect\fP\&.)
.PP
The default stretch factor of newly created rows/columns is 1\&.
.PP
\fBSee also\fP
.RS 4
\fBsetColumnStretchFactor\fP, \fBsetRowStretchFactors\fP 
.RE
.PP

.PP
Definition at line \fB4234\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setFillOrder (\fBFillOrder\fP order, bool rearrange = \fCtrue\fP)"
Sets the filling order and wrapping behaviour that is used when adding new elements with the method \fBaddElement(QCPLayoutElement*)\fP\&.
.PP
The specified \fIorder\fP defines whether rows or columns are filled first\&. Using \fBsetWrap\fP, you can control at which row/column count wrapping into the next column/row will occur\&. If you set it to zero, no wrapping will ever occur\&. Changing the fill order also changes the meaning of the linear index used e\&.g\&. in \fBelementAt\fP and \fBtakeAt\fP\&.
.PP
If you want to have all current elements arranged in the new order, set \fIrearrange\fP to true\&. The elements will be rearranged in a way that tries to preserve their linear index\&. However, empty cells are skipped during build-up of the new cell order, which shifts the succeeding element's index\&. The rearranging is performed even if the specified \fIorder\fP is already the current fill order\&. Thus this method can be used to re-wrap the current elements\&.
.PP
If \fIrearrange\fP is false, the current element arrangement is not changed, which means the linear indexes change (because the linear index is dependent on the fill order)\&.
.PP
Note that the method \fBaddElement(int row, int column, QCPLayoutElement *element)\fP with explicitly stated row and column is not subject to wrapping and can place elements even beyond the specified wrapping point\&.
.PP
\fBSee also\fP
.RS 4
\fBsetWrap\fP, \fBaddElement(QCPLayoutElement*)\fP 
.RE
.PP

.PP
Definition at line \fB4370\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setRowSpacing (int pixels)"
Sets the gap that is left blank between rows to \fIpixels\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBsetColumnSpacing\fP 
.RE
.PP

.PP
Definition at line \fB4319\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setRowStretchFactor (int row, double factor)"
Sets the stretch \fIfactor\fP of \fIrow\fP\&.
.PP
Stretch factors control the relative sizes of rows and columns\&. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor\&. (see \fBQCPLayoutElement::setMinimumSize\fP, \fBQCPLayoutElement::setMaximumSize\fP, \fBQCPLayoutElement::setSizeConstraintRect\fP\&.)
.PP
The default stretch factor of newly created rows/columns is 1\&.
.PP
\fBSee also\fP
.RS 4
\fBsetColumnStretchFactors\fP, \fBsetRowStretchFactor\fP 
.RE
.PP

.PP
Definition at line \fB4263\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setRowStretchFactors (const QList< double > & factors)"
Sets the stretch \fIfactors\fP of all rows\&. \fIfactors\fP must have the size \fBrowCount\fP\&.
.PP
Stretch factors control the relative sizes of rows and columns\&. Cells will not be resized beyond their minimum and maximum widths/heights, regardless of the stretch factor\&. (see \fBQCPLayoutElement::setMinimumSize\fP, \fBQCPLayoutElement::setMaximumSize\fP, \fBQCPLayoutElement::setSizeConstraintRect\fP\&.)
.PP
The default stretch factor of newly created rows/columns is 1\&.
.PP
\fBSee also\fP
.RS 4
\fBsetRowStretchFactor\fP, \fBsetColumnStretchFactors\fP 
.RE
.PP

.PP
Definition at line \fB4287\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::setWrap (int count)"
Sets the maximum number of columns or rows that are used, before new elements added with \fBaddElement(QCPLayoutElement*)\fP will start to fill the next row or column, respectively\&. It depends on \fBsetFillOrder\fP, whether rows or columns are wrapped\&.
.PP
If \fIcount\fP is set to zero, no wrapping will ever occur\&.
.PP
If you wish to re-wrap the elements currently in the layout, call \fBsetFillOrder\fP with \fIrearrange\fP set to true (the actual fill order doesn't need to be changed for the rearranging to be done)\&.
.PP
Note that the method \fBaddElement(int row, int column, QCPLayoutElement *element)\fP with explicitly stated row and column is not subject to wrapping and can place elements even beyond the specified wrapping point\&.
.PP
\fBSee also\fP
.RS 4
\fBsetFillOrder\fP 
.RE
.PP

.PP
Definition at line \fB4341\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::simplify ()\fC [virtual]\fP"
Simplifies the layout by collapsing rows and columns which only contain empty cells\&. 
.PP
Reimplemented from \fBQCPLayout\fP\&.
.PP
Definition at line \fB4671\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPLayoutGrid::take (\fBQCPLayoutElement\fP * element)\fC [virtual]\fP"
Removes the specified \fIelement\fP from the layout and returns true on success\&.
.PP
If the \fIelement\fP isn't in this layout, returns false\&.
.PP
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBtakeAt\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB4629\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayoutGrid::takeAt (int index)\fC [virtual]\fP"
\\seebaseclassmethod
.PP
Note that the association of the linear \fIindex\fP to the row/column based cells depends on the current setting of \fBsetFillOrder\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrowColToIndex\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB4612\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutGrid::updateLayout ()\fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayout\fP\&.
.PP
Definition at line \fB4557\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPLayoutGrid::wrap () const\fC [inline]\fP"

.PP
Definition at line \fB1359\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "int QCPLayoutGrid::mColumnSpacing\fC [protected]\fP"

.PP
Definition at line \fB1399\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<double> QCPLayoutGrid::mColumnStretchFactors\fC [protected]\fP"

.PP
Definition at line \fB1397\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<QList<\fBQCPLayoutElement\fP*> > QCPLayoutGrid::mElements\fC [protected]\fP"

.PP
Definition at line \fB1396\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBFillOrder\fP QCPLayoutGrid::mFillOrder\fC [protected]\fP"

.PP
Definition at line \fB1401\fP of file \fBqcustomplot\&.h\fP\&.
.SS "int QCPLayoutGrid::mRowSpacing\fC [protected]\fP"

.PP
Definition at line \fB1399\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<double> QCPLayoutGrid::mRowStretchFactors\fC [protected]\fP"

.PP
Definition at line \fB1398\fP of file \fBqcustomplot\&.h\fP\&.
.SS "int QCPLayoutGrid::mWrap\fC [protected]\fP"

.PP
Definition at line \fB1400\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
