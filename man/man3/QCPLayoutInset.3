.TH "QCPLayoutInset" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPLayoutInset \- A layout that places child elements aligned to the border or arbitrarily positioned\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPLayout\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBInsetPlacement\fP { \fBipFree\fP, \fBipBorderAligned\fP }"
.br
.in -1c

Public Types inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "enum \fBUpdatePhase\fP { \fBupPreparation\fP, \fBupMargins\fP, \fBupLayout\fP }"
.br
.ti -1c
.RI "enum \fBSizeConstraintRect\fP { \fBscrInnerRect\fP, \fBscrOuterRect\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPLayoutInset\fP ()"
.br
.ti -1c
.RI "\fBInsetPlacement\fP \fBinsetPlacement\fP (int index) const"
.br
.ti -1c
.RI "Qt::Alignment \fBinsetAlignment\fP (int index) const"
.br
.ti -1c
.RI "QRectF \fBinsetRect\fP (int index) const"
.br
.ti -1c
.RI "void \fBsetInsetPlacement\fP (int index, \fBInsetPlacement\fP placement)"
.br
.ti -1c
.RI "void \fBsetInsetAlignment\fP (int index, Qt::Alignment alignment)"
.br
.ti -1c
.RI "void \fBsetInsetRect\fP (int index, const QRectF &\fBrect\fP)"
.br
.ti -1c
.RI "virtual void \fBupdateLayout\fP () Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBelementCount\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBelementAt\fP (int index) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBtakeAt\fP (int index) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual bool \fBtake\fP (\fBQCPLayoutElement\fP *element) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBsimplify\fP () Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBaddElement\fP (\fBQCPLayoutElement\fP *element, Qt::Alignment alignment)"
.br
.ti -1c
.RI "void \fBaddElement\fP (\fBQCPLayoutElement\fP *element, const QRectF &\fBrect\fP)"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "\fBQCPLayout\fP ()"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual int \fBelementCount\fP () const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBelementAt\fP (int index) const =0"
.br
.ti -1c
.RI "virtual \fBQCPLayoutElement\fP * \fBtakeAt\fP (int index)=0"
.br
.ti -1c
.RI "virtual bool \fBtake\fP (\fBQCPLayoutElement\fP *element)=0"
.br
.ti -1c
.RI "virtual void \fBsimplify\fP ()"
.br
.ti -1c
.RI "bool \fBremoveAt\fP (int index)"
.br
.ti -1c
.RI "bool \fBremove\fP (\fBQCPLayoutElement\fP *element)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayoutElement\fP (\fBQCustomPlot\fP *parentPlot=0)"
.br
.ti -1c
.RI "\fBQCPLayout\fP * \fBlayout\fP () const"
.br
.ti -1c
.RI "QRect \fBrect\fP () const"
.br
.ti -1c
.RI "QRect \fBouterRect\fP () const"
.br
.ti -1c
.RI "QMargins \fBmargins\fP () const"
.br
.ti -1c
.RI "QMargins \fBminimumMargins\fP () const"
.br
.ti -1c
.RI "QCP::MarginSides \fBautoMargins\fP () const"
.br
.ti -1c
.RI "QSize \fBminimumSize\fP () const"
.br
.ti -1c
.RI "QSize \fBmaximumSize\fP () const"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBsizeConstraintRect\fP () const"
.br
.ti -1c
.RI "\fBQCPMarginGroup\fP * \fBmarginGroup\fP (\fBQCP::MarginSide\fP side) const"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmarginGroups\fP () const"
.br
.ti -1c
.RI "void \fBsetOuterRect\fP (const QRect &\fBrect\fP)"
.br
.ti -1c
.RI "void \fBsetMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetMinimumMargins\fP (const QMargins &margins)"
.br
.ti -1c
.RI "void \fBsetAutoMargins\fP (QCP::MarginSides sides)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMinimumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (const QSize &size)"
.br
.ti -1c
.RI "void \fBsetMaximumSize\fP (int width, int height)"
.br
.ti -1c
.RI "void \fBsetSizeConstraintRect\fP (\fBSizeConstraintRect\fP constraintRect)"
.br
.ti -1c
.RI "void \fBsetMarginGroup\fP (QCP::MarginSides sides, \fBQCPMarginGroup\fP *group)"
.br
.ti -1c
.RI "virtual void \fBupdate\fP (\fBUpdatePhase\fP phase)"
.br
.ti -1c
.RI "virtual QSize \fBminimumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QSize \fBmaximumOuterSizeHint\fP () const"
.br
.ti -1c
.RI "virtual QList< \fBQCPLayoutElement\fP * > \fBelements\fP (bool recursive) const"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const Q_DECL_OVERRIDE"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "QList< \fBQCPLayoutElement\fP * > \fBmElements\fP"
.br
.ti -1c
.RI "QList< \fBInsetPlacement\fP > \fBmInsetPlacement\fP"
.br
.ti -1c
.RI "QList< Qt::Alignment > \fBmInsetAlignment\fP"
.br
.ti -1c
.RI "QList< QRectF > \fBmInsetRect\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "\fBQCPLayout\fP * \fBmParentLayout\fP"
.br
.ti -1c
.RI "QSize \fBmMinimumSize\fP"
.br
.ti -1c
.RI "QSize \fBmMaximumSize\fP"
.br
.ti -1c
.RI "\fBSizeConstraintRect\fP \fBmSizeConstraintRect\fP"
.br
.ti -1c
.RI "QRect \fBmRect\fP"
.br
.ti -1c
.RI "QRect \fBmOuterRect\fP"
.br
.ti -1c
.RI "QMargins \fBmMargins\fP"
.br
.ti -1c
.RI "QMargins \fBmMinimumMargins\fP"
.br
.ti -1c
.RI "QCP::MarginSides \fBmAutoMargins\fP"
.br
.ti -1c
.RI "QHash< \fBQCP::MarginSide\fP, \fBQCPMarginGroup\fP * > \fBmMarginGroups\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "virtual void \fBupdateLayout\fP ()"
.br
.ti -1c
.RI "void \fBsizeConstraintsChanged\fP () const"
.br
.ti -1c
.RI "void \fBadoptElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "void \fBreleaseElement\fP (\fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "QVector< int > \fBgetSectionSizes\fP (QVector< int > maxSizes, QVector< int > minSizes, QVector< double > stretchFactors, int totalSize) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayoutElement\fP
.in +1c
.ti -1c
.RI "virtual int \fBcalculateAutoMargin\fP (\fBQCP::MarginSide\fP side)"
.br
.ti -1c
.RI "virtual void \fBlayoutChanged\fP ()"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot) Q_DECL_OVERRIDE"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c

Static Protected Member Functions inherited from \fBQCPLayout\fP
.in +1c
.ti -1c
.RI "static QSize \fBgetFinalMinimumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.ti -1c
.RI "static QSize \fBgetFinalMaximumOuterSize\fP (const \fBQCPLayoutElement\fP *el)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A layout that places child elements aligned to the border or arbitrarily positioned\&. 

Elements are placed either aligned to the border or at arbitrary position in the area of the layout\&. Which placement applies is controlled with the \fBInsetPlacement\fP (\fBsetInsetPlacement\fP)\&.
.PP
Elements are added via \fBaddElement(QCPLayoutElement *element, Qt::Alignment alignment)\fP or \fBaddElement(QCPLayoutElement *element, const QRectF &rect)\fP\&. If the first method is used, the inset placement will default to \fBipBorderAligned\fP and the element will be aligned according to the \fIalignment\fP parameter\&. The second method defaults to \fBipFree\fP and allows placing elements at arbitrary position and size, defined by \fIrect\fP\&.
.PP
The alignment or rect can be set via \fBsetInsetAlignment\fP or \fBsetInsetRect\fP, respectively\&.
.PP
This is the layout that every \fBQCPAxisRect\fP has as \fBQCPAxisRect::insetLayout\fP\&. 
.PP
Definition at line \fB1413\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQCPLayoutInset::InsetPlacement\fP"
Defines how the placement and sizing is handled for a certain element in a \fBQCPLayoutInset\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIipFree \fP\fP
The element may be positioned/sized arbitrarily, see \fBsetInsetRect\fP\&. 
.TP
\fB\fIipBorderAligned \fP\fP
The element is aligned to one of the layout sides, see \fBsetInsetAlignment\fP\&. 
.PP
Definition at line \fB1420\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPLayoutInset::QCPLayoutInset ()\fC [explicit]\fP"
Creates an instance of \fBQCPLayoutInset\fP and sets default values\&. 
.PP
Definition at line \fB4855\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPLayoutInset::~QCPLayoutInset ()\fC [virtual]\fP"

.PP
Definition at line \fB4859\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void QCPLayoutInset::addElement (\fBQCPLayoutElement\fP * element, const QRectF & rect)"
Adds the specified \fIelement\fP to the layout as an inset with free positioning/sizing (\fBsetInsetAlignment\fP is initialized with \fBipFree\fP)\&. The position and size is set to \fIrect\fP\&.
.PP
\fIrect\fP is given in fractions of the whole inset layout rect\&. So an inset with rect (0, 0, 1, 1) will span the entire layout\&. An inset with rect (0\&.6, 0\&.1, 0\&.35, 0\&.35) will be in the top right corner of the layout, with 35% width and height of the parent layout\&.
.PP
\fBSee also\fP
.RS 4
\fBaddElement(QCPLayoutElement *element, Qt::Alignment alignment)\fP 
.RE
.PP

.PP
Definition at line \fB5110\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::addElement (\fBQCPLayoutElement\fP * element, Qt::Alignment alignment)"
Adds the specified \fIelement\fP to the layout as an inset aligned at the border (\fBsetInsetAlignment\fP is initialized with \fBipBorderAligned\fP)\&. The alignment is set to \fIalignment\fP\&.
.PP
\fIalignment\fP is an or combination of the following alignment flags: Qt::AlignLeft, Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom\&. Any other alignment flags will be ignored\&.
.PP
\fBSee also\fP
.RS 4
\fBaddElement(QCPLayoutElement *element, const QRectF &rect)\fP 
.RE
.PP

.PP
Definition at line \fB5084\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayoutInset::elementAt (int index) const\fC [virtual]\fP"
Returns the element in the cell with the given \fIindex\fP\&. If \fIindex\fP is invalid, returns 0\&.
.PP
Note that even if \fIindex\fP is valid, the respective cell may be empty in some layouts (e\&.g\&. \fBQCPLayoutGrid\fP), so this function may return 0 in those cases\&. You may use this function to check whether a cell is empty or not\&.
.PP
\fBSee also\fP
.RS 4
\fBelements\fP, \fBelementCount\fP, \fBtakeAt\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB5003\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "int QCPLayoutInset::elementCount () const\fC [virtual]\fP"
Returns the number of elements/cells in the layout\&.
.PP
\fBSee also\fP
.RS 4
\fBelements\fP, \fBelementAt\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB4997\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "Qt::Alignment QCPLayoutInset::insetAlignment (int index) const"
Returns the alignment of the element with the specified \fIindex\fP\&. The alignment only has a meaning, if the inset placement (\fBsetInsetPlacement\fP) is \fBipBorderAligned\fP\&. 
.PP
Definition at line \fB4884\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutInset::InsetPlacement\fP QCPLayoutInset::insetPlacement (int index) const"
Returns the placement type of the element with the specified \fIindex\fP\&. 
.PP
Definition at line \fB4869\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QRectF QCPLayoutInset::insetRect (int index) const"
Returns the rect of the element with the specified \fIindex\fP\&. The rect only has a meaning, if the inset placement (\fBsetInsetPlacement\fP) is \fBipFree\fP\&. 
.PP
Definition at line \fB4899\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "double QCPLayoutInset::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [virtual]\fP"
The inset layout is sensitive to events only at areas where its (visible) child elements are sensitive\&. If the selectTest method of any of the child elements returns a positive number for \fIpos\fP, this method returns a value corresponding to 0\&.99 times the parent plot's selection tolerance\&. The inset layout is not selectable itself by default\&. So if \fIonlySelectable\fP is true, -1\&.0 is returned\&.
.PP
See \fBQCPLayerable::selectTest\fP for a general explanation of this virtual method\&. 
.PP
Reimplemented from \fBQCPLayoutElement\fP\&.
.PP
Definition at line \fB5057\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::setInsetAlignment (int index, Qt::Alignment alignment)"
If the inset placement (\fBsetInsetPlacement\fP) is \fBipBorderAligned\fP, this function is used to set the alignment of the element with the specified \fIindex\fP to \fIalignment\fP\&.
.PP
\fIalignment\fP is an or combination of the following alignment flags: Qt::AlignLeft, Qt::AlignHCenter, Qt::AlighRight, Qt::AlignTop, Qt::AlignVCenter, Qt::AlignBottom\&. Any other alignment flags will be ignored\&. 
.PP
Definition at line \fB4931\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::setInsetPlacement (int index, \fBQCPLayoutInset::InsetPlacement\fP placement)"
Sets the inset placement type of the element with the specified \fIindex\fP to \fIplacement\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBInsetPlacement\fP 
.RE
.PP

.PP
Definition at line \fB4915\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::setInsetRect (int index, const QRectF & rect)"
If the inset placement (\fBsetInsetPlacement\fP) is \fBipFree\fP, this function is used to set the position and size of the element with the specified \fIindex\fP to \fIrect\fP\&.
.PP
\fIrect\fP is given in fractions of the whole inset layout rect\&. So an inset with rect (0, 0, 1, 1) will span the entire layout\&. An inset with rect (0\&.6, 0\&.1, 0\&.35, 0\&.35) will be in the top right corner of the layout, with 35% width and height of the parent layout\&.
.PP
Note that the minimum and maximum sizes of the embedded element (\fBQCPLayoutElement::setMinimumSize\fP, \fBQCPLayoutElement::setMaximumSize\fP) are enforced\&. 
.PP
Definition at line \fB4950\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::simplify ()\fC [inline]\fP, \fC [virtual]\fP"
The QCPInsetLayout does not need simplification since it can never have empty cells due to its linear index structure\&. This method does nothing\&. 
.PP
Reimplemented from \fBQCPLayout\fP\&.
.PP
Definition at line \fB1444\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPLayoutInset::take (\fBQCPLayoutElement\fP * element)\fC [virtual]\fP"
Removes the specified \fIelement\fP from the layout and returns true on success\&.
.PP
If the \fIelement\fP isn't in this layout, returns false\&.
.PP
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBtakeAt\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB5030\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPLayoutElement\fP * QCPLayoutInset::takeAt (int index)\fC [virtual]\fP"
Removes the element with the given \fIindex\fP from the layout and returns it\&.
.PP
If the \fIindex\fP is invalid or the cell with that index is empty, returns 0\&.
.PP
Note that some layouts don't remove the respective cell right away but leave an empty cell after successful removal of the layout element\&. To collapse empty cells, use \fBsimplify\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBelementAt\fP, \fBtake\fP 
.RE
.PP

.PP
Implements \fBQCPLayout\fP\&.
.PP
Definition at line \fB5012\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPLayoutInset::updateLayout ()\fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayout\fP\&.
.PP
Definition at line \fB4959\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "QList<\fBQCPLayoutElement\fP*> QCPLayoutInset::mElements\fC [protected]\fP"

.PP
Definition at line \fB1453\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<Qt::Alignment> QCPLayoutInset::mInsetAlignment\fC [protected]\fP"

.PP
Definition at line \fB1455\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<\fBInsetPlacement\fP> QCPLayoutInset::mInsetPlacement\fC [protected]\fP"

.PP
Definition at line \fB1454\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QList<QRectF> QCPLayoutInset::mInsetRect\fC [protected]\fP"

.PP
Definition at line \fB1456\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
