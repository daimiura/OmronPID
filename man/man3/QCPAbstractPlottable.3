.TH "QCPAbstractPlottable" 3 "Wed Mar 15 2023" "OmronPID" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QCPAbstractPlottable \- The abstract base class for all data representing objects in a plot\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBQCPLayerable\fP\&.
.PP
Inherited by \fBQCPAbstractPlottable1D< QCPBarsData >\fP, \fBQCPAbstractPlottable1D< QCPCurveData >\fP, \fBQCPAbstractPlottable1D< QCPFinancialData >\fP, \fBQCPAbstractPlottable1D< QCPGraphData >\fP, \fBQCPAbstractPlottable1D< QCPStatisticalBoxData >\fP, \fBQCPAbstractPlottable1D< DataType >\fP, \fBQCPColorMap\fP, and \fBQCPErrorBars\fP\&.
.SS "Signals"

.in +1c
.ti -1c
.RI "void \fBselectionChanged\fP (bool \fBselected\fP)"
.br
.ti -1c
.RI "void \fBselectionChanged\fP (const \fBQCPDataSelection\fP &\fBselection\fP)"
.br
.ti -1c
.RI "void \fBselectableChanged\fP (\fBQCP::SelectionType\fP selectable)"
.br
.in -1c

Signals inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "void \fBlayerChanged\fP (\fBQCPLayer\fP *newLayer)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQCPAbstractPlottable\fP (\fBQCPAxis\fP *keyAxis, \fBQCPAxis\fP *valueAxis)"
.br
.ti -1c
.RI "QString \fBname\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedFill\fP () const"
.br
.ti -1c
.RI "bool \fBantialiasedScatters\fP () const"
.br
.ti -1c
.RI "QPen \fBpen\fP () const"
.br
.ti -1c
.RI "QBrush \fBbrush\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBkeyAxis\fP () const"
.br
.ti -1c
.RI "\fBQCPAxis\fP * \fBvalueAxis\fP () const"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBselectable\fP () const"
.br
.ti -1c
.RI "bool \fBselected\fP () const"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBselection\fP () const"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBselectionDecorator\fP () const"
.br
.ti -1c
.RI "void \fBsetName\fP (const QString &name)"
.br
.ti -1c
.RI "void \fBsetAntialiasedFill\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetAntialiasedScatters\fP (bool enabled)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &pen)"
.br
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &brush)"
.br
.ti -1c
.RI "void \fBsetKeyAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "void \fBsetValueAxis\fP (\fBQCPAxis\fP *axis)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelectable\fP (\fBQCP::SelectionType\fP selectable)"
.br
.ti -1c
.RI "Q_SLOT void \fBsetSelection\fP (\fBQCPDataSelection\fP \fBselection\fP)"
.br
.ti -1c
.RI "void \fBsetSelectionDecorator\fP (\fBQCPSelectionDecorator\fP *decorator)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const =0"
.br
.ti -1c
.RI "virtual \fBQCPPlottableInterface1D\fP * \fBinterface1D\fP ()"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetKeyRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP) const =0"
.br
.ti -1c
.RI "virtual \fBQCPRange\fP \fBgetValueRange\fP (bool &foundRange, \fBQCP::SignDomain\fP inSignDomain=\fBQCP::sdBoth\fP, const \fBQCPRange\fP &inKeyRange=\fBQCPRange\fP()) const =0"
.br
.ti -1c
.RI "void \fBcoordsToPixels\fP (double key, double value, double &x, double &y) const"
.br
.ti -1c
.RI "const QPointF \fBcoordsToPixels\fP (double key, double value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (double x, double y, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBpixelsToCoords\fP (const QPointF &pixelPos, double &key, double &value) const"
.br
.ti -1c
.RI "void \fBrescaleAxes\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleKeyAxis\fP (bool onlyEnlarge=false) const"
.br
.ti -1c
.RI "void \fBrescaleValueAxis\fP (bool onlyEnlarge=false, bool inKeyRange=false) const"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP (\fBQCPLegend\fP *legend)"
.br
.ti -1c
.RI "bool \fBaddToLegend\fP ()"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP (\fBQCPLegend\fP *legend) const"
.br
.ti -1c
.RI "bool \fBremoveFromLegend\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "\fBQCPLayerable\fP (\fBQCustomPlot\fP *plot, QString targetLayer=QString(), \fBQCPLayerable\fP *\fBparentLayerable\fP=0)"
.br
.ti -1c
.RI "bool \fBvisible\fP () const"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBparentPlot\fP () const"
.br
.ti -1c
.RI "\fBQCPLayerable\fP * \fBparentLayerable\fP () const"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBlayer\fP () const"
.br
.ti -1c
.RI "bool \fBantialiased\fP () const"
.br
.ti -1c
.RI "void \fBsetVisible\fP (bool on)"
.br
.ti -1c
.RI "Q_SLOT bool \fBsetLayer\fP (\fBQCPLayer\fP *layer)"
.br
.ti -1c
.RI "bool \fBsetLayer\fP (const QString &layerName)"
.br
.ti -1c
.RI "void \fBsetAntialiased\fP (bool enabled)"
.br
.ti -1c
.RI "virtual double \fBselectTest\fP (const QPointF &pos, bool onlySelectable, QVariant *details=0) const"
.br
.ti -1c
.RI "bool \fBrealVisibility\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter) Q_DECL_OVERRIDE=0"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged) Q_DECL_OVERRIDE"
.br
.ti -1c
.RI "virtual void \fBdrawLegendIcon\fP (\fBQCPPainter\fP *painter, const QRectF &rect) const =0"
.br
.ti -1c
.RI "void \fBapplyFillAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.ti -1c
.RI "void \fBapplyScattersAntialiasingHint\fP (\fBQCPPainter\fP *painter) const"
.br
.in -1c

Protected Member Functions inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "virtual void \fBparentPlotInitialized\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "virtual \fBQCP::Interaction\fP \fBselectionCategory\fP () const"
.br
.ti -1c
.RI "virtual QRect \fBclipRect\fP () const"
.br
.ti -1c
.RI "virtual void \fBapplyDefaultAntialiasingHint\fP (\fBQCPPainter\fP *painter) const =0"
.br
.ti -1c
.RI "virtual void \fBdraw\fP (\fBQCPPainter\fP *painter)=0"
.br
.ti -1c
.RI "virtual void \fBselectEvent\fP (QMouseEvent *event, bool additive, const QVariant &details, bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBdeselectEvent\fP (bool *selectionStateChanged)"
.br
.ti -1c
.RI "virtual void \fBmousePressEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBmouseMoveEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseReleaseEvent\fP (QMouseEvent *event, const QPointF &startPos)"
.br
.ti -1c
.RI "virtual void \fBmouseDoubleClickEvent\fP (QMouseEvent *event, const QVariant &details)"
.br
.ti -1c
.RI "virtual void \fBwheelEvent\fP (QWheelEvent *event)"
.br
.ti -1c
.RI "void \fBinitializeParentPlot\fP (\fBQCustomPlot\fP *parentPlot)"
.br
.ti -1c
.RI "void \fBsetParentLayerable\fP (\fBQCPLayerable\fP *\fBparentLayerable\fP)"
.br
.ti -1c
.RI "bool \fBmoveToLayer\fP (\fBQCPLayer\fP *layer, bool prepend)"
.br
.ti -1c
.RI "void \fBapplyAntialiasingHint\fP (\fBQCPPainter\fP *painter, bool localAntialiased, \fBQCP::AntialiasedElement\fP overrideElement) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "QString \fBmName\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedFill\fP"
.br
.ti -1c
.RI "bool \fBmAntialiasedScatters\fP"
.br
.ti -1c
.RI "QPen \fBmPen\fP"
.br
.ti -1c
.RI "QBrush \fBmBrush\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmKeyAxis\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPAxis\fP > \fBmValueAxis\fP"
.br
.ti -1c
.RI "\fBQCP::SelectionType\fP \fBmSelectable\fP"
.br
.ti -1c
.RI "\fBQCPDataSelection\fP \fBmSelection\fP"
.br
.ti -1c
.RI "\fBQCPSelectionDecorator\fP * \fBmSelectionDecorator\fP"
.br
.in -1c

Protected Attributes inherited from \fBQCPLayerable\fP
.in +1c
.ti -1c
.RI "bool \fBmVisible\fP"
.br
.ti -1c
.RI "\fBQCustomPlot\fP * \fBmParentPlot\fP"
.br
.ti -1c
.RI "QPointer< \fBQCPLayerable\fP > \fBmParentLayerable\fP"
.br
.ti -1c
.RI "\fBQCPLayer\fP * \fBmLayer\fP"
.br
.ti -1c
.RI "bool \fBmAntialiased\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBQCustomPlot\fP"
.br
.ti -1c
.RI "class \fBQCPAxis\fP"
.br
.ti -1c
.RI "class \fBQCPPlottableLegendItem\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The abstract base class for all data representing objects in a plot\&. 

It defines a very basic interface like name, pen, brush, visibility etc\&. Since this class is abstract, it can't be instantiated\&. Use one of the subclasses or create a subclass yourself to create new ways of displaying data (see 'Creating own plottables' below)\&. Plottables that display one-dimensional data (i\&.e\&. data points have a single key dimension and one or multiple values at each key) are based off of the template subclass \fBQCPAbstractPlottable1D\fP, see details there\&.
.PP
All further specifics are in the subclasses, for example: 
.PD 0

.IP "\(bu" 2
A normal graph with possibly a line and/or scatter points \fBQCPGraph\fP (typically created with \fBQCustomPlot::addGraph\fP) 
.IP "\(bu" 2
A parametric curve: \fBQCPCurve\fP 
.IP "\(bu" 2
A bar chart: \fBQCPBars\fP 
.IP "\(bu" 2
A statistical box plot: \fBQCPStatisticalBox\fP 
.IP "\(bu" 2
A color encoded two-dimensional map: \fBQCPColorMap\fP 
.IP "\(bu" 2
An OHLC/Candlestick chart: \fBQCPFinancial\fP
.PP
.SH "Creating own plottables"
.PP
Subclassing directly from \fBQCPAbstractPlottable\fP is only recommended if you wish to display two-dimensional data like \fBQCPColorMap\fP, i\&.e\&. two logical key dimensions and one (or more) data dimensions\&. If you want to display data with only one logical key dimension, you should rather derive from \fBQCPAbstractPlottable1D\fP\&.
.PP
If subclassing \fBQCPAbstractPlottable\fP directly, these are the pure virtual functions you must implement: 
.PD 0

.IP "\(bu" 2
\fBselectTest\fP 
.IP "\(bu" 2
\fBdraw\fP 
.IP "\(bu" 2
\fBdrawLegendIcon\fP 
.IP "\(bu" 2
\fBgetKeyRange\fP 
.IP "\(bu" 2
\fBgetValueRange\fP
.PP
See the documentation of those functions for what they need to do\&.
.PP
For drawing your plot, you can use the \fBcoordsToPixels\fP functions to translate a point in plot coordinates to pixel coordinates\&. This function is quite convenient, because it takes the orientation of the key and value axes into account for you (x and y are swapped when the key axis is vertical and the value axis horizontal)\&. If you are worried about performance (i\&.e\&. you need to translate many points in a loop like \fBQCPGraph\fP), you can directly use \fBQCPAxis::coordToPixel\fP\&. However, you must then take care about the orientation of the axis yourself\&.
.PP
Here are some important members you inherit from \fBQCPAbstractPlottable\fP: \fBQCustomPlot\fP *\fBmParentPlot\fP  A pointer to the parent \fBQCustomPlot\fP instance\&. The parent plot is inferred from the axes that are passed in the constructor\&. QString \fBmName\fP  The name of the plottable\&. QPen \fBmPen\fP  The generic pen of the plottable\&. You should use this pen for the most prominent data representing lines in the plottable (e\&.g \fBQCPGraph\fP uses this pen for its graph lines and scatters) QBrush \fBmBrush\fP  The generic brush of the plottable\&. You should use this brush for the most prominent fillable structures in the plottable (e\&.g\&. \fBQCPGraph\fP uses this brush to control filling under the graph) QPointer<\fBQCPAxis\fP> \fBmKeyAxis\fP, \fBmValueAxis\fP  The key and value axes this plottable is attached to\&. Call their \fBQCPAxis::coordToPixel\fP functions to translate coordinates to pixels in either the key or value dimension\&. Make sure to check whether the pointer is null before using it\&. If one of the axes is null, don't draw the plottable\&. \fBQCPSelectionDecorator\fP \fBmSelectionDecorator\fP  The currently set selection decorator which specifies how selected data of the plottable shall be drawn and decorated\&. When drawing your data, you must consult this decorator for the appropriate pen/brush before drawing unselected/selected data segments\&. Finally, you should call its \fBQCPSelectionDecorator::drawDecoration\fP method at the end of your \fBdraw\fP implementation\&. \fBQCP::SelectionType\fP \fBmSelectable\fP  In which composition, if at all, this plottable's data may be selected\&. Enforcing this setting on the data selection is done by \fBQCPAbstractPlottable\fP automatically\&. \fBQCPDataSelection\fP \fBmSelection\fP  Holds the current selection state of the plottable's data, i\&.e\&. the selected data ranges (\fBQCPDataRange\fP)\&.  
.PP
Definition at line \fB3287\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QCPAbstractPlottable::QCPAbstractPlottable (\fBQCPAxis\fP * keyAxis, \fBQCPAxis\fP * valueAxis)"
Constructs an abstract plottable which uses \fIkeyAxis\fP as its key axis ('x') and \fIvalueAxis\fP as its value axis ('y')\&. \fIkeyAxis\fP and \fIvalueAxis\fP must reside in the same \fBQCustomPlot\fP instance and have perpendicular orientations\&. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though\&.
.PP
Since \fBQCPAbstractPlottable\fP is an abstract class that defines the basic interface to plottables, it can't be directly instantiated\&.
.PP
You probably want one of the subclasses like \fBQCPGraph\fP or \fBQCPCurve\fP instead\&. 
.PP
Definition at line \fB10690\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QCPAbstractPlottable::~QCPAbstractPlottable ()\fC [virtual]\fP"

.PP
Definition at line \fB10711\fP of file \fBqcustomplot\&.cpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "bool QCPAbstractPlottable::addToLegend ()"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds this plottable to the legend of the parent \fBQCustomPlot\fP (\fBQCustomPlot::legend\fP)\&.
.PP
\fBSee also\fP
.RS 4
\fBremoveFromLegend\fP 
.RE
.PP

.PP
Definition at line \fB11110\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPAbstractPlottable::addToLegend (\fBQCPLegend\fP * legend)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Adds this plottable to the specified \fIlegend\fP\&.
.PP
Creates a \fBQCPPlottableLegendItem\fP which is inserted into the legend\&. Returns true on success, i\&.e\&. when the legend exists and a legend item associated with this plottable isn't already in the legend\&.
.PP
If the plottable needs a more specialized representation in the legend, you can create a corresponding subclass of \fBQCPPlottableLegendItem\fP and add it to the legend manually instead of calling this method\&.
.PP
\fBSee also\fP
.RS 4
\fBremoveFromLegend\fP, \fBQCPLegend::addItem\fP 
.RE
.PP

.PP
Definition at line \fB11083\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPAbstractPlottable::antialiasedFill () const\fC [inline]\fP"

.PP
Definition at line \fB3308\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPAbstractPlottable::antialiasedScatters () const\fC [inline]\fP"

.PP
Definition at line \fB3309\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPAbstractPlottable::applyDefaultAntialiasingHint (\fBQCPPainter\fP * painter) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implements \fBQCPLayerable\fP\&.
.PP
Definition at line \fB11186\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::applyFillAntialiasingHint (\fBQCPPainter\fP * painter) const\fC [protected]\fP"

.PP
Definition at line \fB11202\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::applyScattersAntialiasingHint (\fBQCPPainter\fP * painter) const\fC [protected]\fP"

.PP
Definition at line \fB11218\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "QBrush QCPAbstractPlottable::brush () const\fC [inline]\fP"

.PP
Definition at line \fB3311\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QRect QCPAbstractPlottable::clipRect () const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayerable\fP\&.
.PP
Definition at line \fB11157\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "const QPointF QCPAbstractPlottable::coordsToPixels (double key, double value) const"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Transforms the given \fIkey\fP and \fIvalue\fP to pixel coordinates and returns them in a QPointF\&. 
.PP
Definition at line \fB10923\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::coordsToPixels (double key, double value, double & x, double & y) const"
Convenience function for transforming a key/value pair to pixels on the \fBQCustomPlot\fP surface, taking the orientations of the axes associated with this plottable into account (e\&.g\&. whether key represents x or y)\&.
.PP
\fIkey\fP and \fIvalue\fP are transformed to the coodinates in pixels and are written to \fIx\fP and \fIy\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBpixelsToCoords\fP, \fBQCPAxis::coordToPixel\fP 
.RE
.PP

.PP
Definition at line \fB10902\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::deselectEvent (bool * selectionStateChanged)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayerable\fP\&.
.PP
Definition at line \fB11255\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "virtual void QCPAbstractPlottable::draw (\fBQCPPainter\fP * painter)\fC [protected]\fP, \fC [pure virtual]\fP"

.PP
Implements \fBQCPLayerable\fP\&.
.SS "\fBQCPRange\fP QCPAbstractPlottable::getKeyRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP) const\fC [pure virtual]\fP"
Returns the coordinate range that all data in this plottable span in the key axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetValueRange\fP 
.RE
.PP

.PP
Implemented in \fBQCPGraph\fP, \fBQCPCurve\fP, \fBQCPBars\fP, \fBQCPStatisticalBox\fP, \fBQCPColorMap\fP, \fBQCPFinancial\fP, and \fBQCPErrorBars\fP\&.
.SS "\fBQCPRange\fP QCPAbstractPlottable::getValueRange (bool & foundRange, \fBQCP::SignDomain\fP inSignDomain = \fC\fBQCP::sdBoth\fP\fP, const \fBQCPRange\fP & inKeyRange = \fC\fBQCPRange\fP()\fP) const\fC [pure virtual]\fP"
Returns the coordinate range that the data points in the specified key range (\fIinKeyRange\fP) span in the value axis dimension\&. For logarithmic plots, one can set \fIinSignDomain\fP to either \fBQCP::sdNegative\fP or \fBQCP::sdPositive\fP in order to restrict the returned range to that sign domain\&. E\&.g\&. when only negative range is wanted, set \fIinSignDomain\fP to \fBQCP::sdNegative\fP and all positive points will be ignored for range calculation\&. For no restriction, just set \fIinSignDomain\fP to \fBQCP::sdBoth\fP (default)\&. \fIfoundRange\fP is an output parameter that indicates whether a range could be found or not\&. If this is false, you shouldn't use the returned range (e\&.g\&. no points in data)\&.
.PP
If \fIinKeyRange\fP has both lower and upper bound set to zero (is equal to \fC\fBQCPRange()\fP\fP), all data points are considered, without any restriction on the keys\&.
.PP
Note that \fIfoundRange\fP is not the same as \fBQCPRange::validRange\fP, since the range returned by this function may have size zero (e\&.g\&. when there is only one data point)\&. In this case \fIfoundRange\fP would return true, but the returned range is not a valid range in terms of \fBQCPRange::validRange\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleAxes\fP, \fBgetKeyRange\fP 
.RE
.PP

.PP
Implemented in \fBQCPGraph\fP, \fBQCPCurve\fP, \fBQCPBars\fP, \fBQCPStatisticalBox\fP, \fBQCPColorMap\fP, \fBQCPFinancial\fP, and \fBQCPErrorBars\fP\&.
.SS "\fBQCPPlottableInterface1D\fP * QCPAbstractPlottable::interface1D ()\fC [inline]\fP, \fC [virtual]\fP"
If this plottable is a one-dimensional plottable, i\&.e\&. it implements the \fBQCPPlottableInterface1D\fP, returns the \fIthis\fP pointer with that type\&. Otherwise (e\&.g\&. in the case of a \fBQCPColorMap\fP) returns zero\&.
.PP
You can use this method to gain read access to data coordinates while holding a pointer to the abstract base class only\&. 
.PP
Reimplemented in \fBQCPAbstractPlottable1D< DataType >\fP, \fBQCPAbstractPlottable1D< QCPBarsData >\fP, \fBQCPAbstractPlottable1D< QCPCurveData >\fP, \fBQCPAbstractPlottable1D< QCPFinancialData >\fP, \fBQCPAbstractPlottable1D< QCPGraphData >\fP, \fBQCPAbstractPlottable1D< QCPStatisticalBoxData >\fP, and \fBQCPErrorBars\fP\&.
.PP
Definition at line \fB3333\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPAxis\fP * QCPAbstractPlottable::keyAxis () const\fC [inline]\fP"

.PP
Definition at line \fB3312\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QString QCPAbstractPlottable::name () const\fC [inline]\fP"

.PP
Definition at line \fB3307\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPen QCPAbstractPlottable::pen () const\fC [inline]\fP"

.PP
Definition at line \fB3310\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPAbstractPlottable::pixelsToCoords (const QPointF & pixelPos, double & key, double & value) const"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Returns the pixel input \fIpixelPos\fP as plot coordinates \fIkey\fP and \fIvalue\fP\&. 
.PP
Definition at line \fB10965\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::pixelsToCoords (double x, double y, double & key, double & value) const"
Convenience function for transforming a x/y pixel pair on the \fBQCustomPlot\fP surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e\&.g\&. whether key represents x or y)\&.
.PP
\fIx\fP and \fIy\fP are transformed to the plot coodinates and are written to \fIkey\fP and \fIvalue\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBcoordsToPixels\fP, \fBQCPAxis::coordToPixel\fP 
.RE
.PP

.PP
Definition at line \fB10944\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPAbstractPlottable::removeFromLegend () const"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Removes the plottable from the legend of the parent \fBQCustomPlot\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBaddToLegend\fP 
.RE
.PP

.PP
Definition at line \fB11148\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "bool QCPAbstractPlottable::removeFromLegend (\fBQCPLegend\fP * legend) const"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.PP
Removes the plottable from the specifed \fIlegend\fP\&. This means the \fBQCPPlottableLegendItem\fP that is associated with this plottable is removed\&.
.PP
Returns true on success, i\&.e\&. if the legend exists and a legend item associated with this plottable was found and removed\&.
.PP
\fBSee also\fP
.RS 4
\fBaddToLegend\fP, \fBQCPLegend::removeItem\fP 
.RE
.PP

.PP
Definition at line \fB11128\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::rescaleAxes (bool onlyEnlarge = \fCfalse\fP) const"
Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible\&. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i\&.e\&. a range containing different signs and/or zero\&. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain\&.
.PP
\fIonlyEnlarge\fP makes sure the ranges are only expanded, never reduced\&. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has \fIonlyEnlarge\fP set to false (the default), and all subsequent set to true\&.
.PP
\fBSee also\fP
.RS 4
\fBrescaleKeyAxis\fP, \fBrescaleValueAxis\fP, \fBQCustomPlot::rescaleAxes\fP, \fBQCPAxis::rescale\fP 
.RE
.PP

.PP
Definition at line \fB10983\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::rescaleKeyAxis (bool onlyEnlarge = \fCfalse\fP) const"
Rescales the key axis of the plottable so the whole plottable is visible\&.
.PP
See \fBrescaleAxes\fP for detailed behaviour\&. 
.PP
Definition at line \fB10994\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::rescaleValueAxis (bool onlyEnlarge = \fCfalse\fP, bool inKeyRange = \fCfalse\fP) const"
Rescales the value axis of the plottable so the whole plottable is visible\&. If \fIinKeyRange\fP is set to true, only the data points which are in the currently visible key axis range are considered\&.
.PP
Returns true if the axis was actually scaled\&. This might not be the case if this plottable has an invalid range, e\&.g\&. because it has no data points\&.
.PP
See \fBrescaleAxes\fP for detailed behaviour\&. 
.PP
Definition at line \fB11036\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCP::SelectionType\fP QCPAbstractPlottable::selectable () const\fC [inline]\fP"

.PP
Definition at line \fB3314\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPAbstractPlottable::selectableChanged (\fBQCP::SelectionType\fP selectable)\fC [signal]\fP"
This signal is emitted when the selectability of this plottable has changed\&.
.PP
\fBSee also\fP
.RS 4
\fBsetSelectable\fP 
.RE
.PP

.SS "bool QCPAbstractPlottable::selected () const\fC [inline]\fP"
Returns true if there are any data points of the plottable currently selected\&. Use \fBselection\fP to retrieve the current \fBQCPDataSelection\fP\&. 
.PP
Definition at line \fB3315\fP of file \fBqcustomplot\&.h\fP\&.
.SS "void QCPAbstractPlottable::selectEvent (QMouseEvent * event, bool additive, const QVariant & details, bool * selectionStateChanged)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayerable\fP\&.
.PP
Definition at line \fB11224\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPDataSelection\fP QCPAbstractPlottable::selection () const\fC [inline]\fP"
Returns a \fBQCPDataSelection\fP encompassing all the data points that are currently selected on this plottable\&.
.PP
\fBSee also\fP
.RS 4
\fBselected\fP, \fBsetSelection\fP, \fBsetSelectable\fP 
.RE
.PP

.PP
Definition at line \fB3316\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCP::Interaction\fP QCPAbstractPlottable::selectionCategory () const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBQCPLayerable\fP\&.
.PP
Definition at line \fB11166\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::selectionChanged (bool selected)\fC [signal]\fP"
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to \fBsetSelection\fP\&. The parameter \fIselected\fP indicates whether there are any points selected or not\&.
.PP
\fBSee also\fP
.RS 4
\fBselectionChanged(const QCPDataSelection &selection)\fP 
.RE
.PP

.SS "void QCPAbstractPlottable::selectionChanged (const \fBQCPDataSelection\fP & selection)\fC [signal]\fP"
This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to \fBsetSelection\fP\&. The parameter \fIselection\fP holds the currently selected data ranges\&.
.PP
\fBSee also\fP
.RS 4
\fBselectionChanged(bool selected)\fP 
.RE
.PP

.SS "\fBQCPSelectionDecorator\fP * QCPAbstractPlottable::selectionDecorator () const\fC [inline]\fP"
Provides access to the selection decorator of this plottable\&. The selection decorator controls how selected data ranges are drawn (e\&.g\&. their pen color and fill), see \fBQCPSelectionDecorator\fP for details\&.
.PP
If you wish to use an own \fBQCPSelectionDecorator\fP subclass, pass an instance of it to \fBsetSelectionDecorator\fP\&. 
.PP
Definition at line \fB3317\fP of file \fBqcustomplot\&.h\fP\&.
.SS "virtual double QCPAbstractPlottable::selectTest (const QPointF & pos, bool onlySelectable, QVariant * details = \fC0\fP) const\fC [pure virtual]\fP"
This function is used to decide whether a click hits a layerable object or not\&.
.PP
\fIpos\fP is a point in pixel coordinates on the \fBQCustomPlot\fP surface\&. This function returns the shortest pixel distance of this point to the object\&. If the object is either invisible or the distance couldn't be determined, -1\&.0 is returned\&. Further, if \fIonlySelectable\fP is true and the object is not selectable, -1\&.0 is returned, too\&.
.PP
If the object is represented not by single lines but by an area like a \fBQCPItemText\fP or the bars of a \fBQCPBars\fP plottable, a click inside the area should also be considered a hit\&. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance\&. (typically the selectionTolerance multiplied by 0\&.99)\&.
.PP
Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i\&.e\&. closer than 0\&.99*selectionTolerance)\&.
.PP
The actual setting of the selection state is not done by this function\&. This is handled by the parent \fBQCustomPlot\fP when the mouseReleaseEvent occurs, and the finally selected object is notified via the \fBselectEvent/\fP deselectEvent methods\&.
.PP
\fIdetails\fP is an optional output parameter\&. Every layerable subclass may place any information in \fIdetails\fP\&. This information will be passed to \fBselectEvent\fP when the parent \fBQCustomPlot\fP decides on the basis of this selectTest call, that the object was successfully selected\&. The subsequent call to \fBselectEvent\fP will carry the \fIdetails\fP\&. This is useful for multi-part objects (like \fBQCPAxis\fP)\&. This way, a possibly complex calculation to decide which part was clicked is only done once in \fBselectTest\fP\&. The result (i\&.e\&. the actually clicked part) can then be placed in \fIdetails\fP\&. So in the subsequent \fBselectEvent\fP, the decision which part was selected doesn't have to be done a second time for a single selection operation\&.
.PP
You may pass 0 as \fIdetails\fP to indicate that you are not interested in those selection details\&.
.PP
\fBSee also\fP
.RS 4
selectEvent, deselectEvent, \fBmousePressEvent\fP, \fBwheelEvent\fP, \fBQCustomPlot::setInteractions\fP 
.RE
.PP

.PP
Reimplemented from \fBQCPLayerable\fP\&.
.PP
Implemented in \fBQCPAbstractPlottable1D< DataType >\fP, \fBQCPAbstractPlottable1D< QCPBarsData >\fP, \fBQCPAbstractPlottable1D< QCPCurveData >\fP, \fBQCPAbstractPlottable1D< QCPFinancialData >\fP, \fBQCPAbstractPlottable1D< QCPGraphData >\fP, \fBQCPAbstractPlottable1D< QCPStatisticalBoxData >\fP, \fBQCPGraph\fP, \fBQCPCurve\fP, \fBQCPBars\fP, \fBQCPStatisticalBox\fP, \fBQCPColorMap\fP, \fBQCPFinancial\fP, and \fBQCPErrorBars\fP\&.
.SS "void QCPAbstractPlottable::setAntialiasedFill (bool enabled)"
Sets whether fills of this plottable are drawn antialiased or not\&.
.PP
Note that this setting may be overridden by \fBQCustomPlot::setAntialiasedElements\fP and \fBQCustomPlot::setNotAntialiasedElements\fP\&. 
.PP
Definition at line \fB10735\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setAntialiasedScatters (bool enabled)"
Sets whether the scatter symbols of this plottable are drawn antialiased or not\&.
.PP
Note that this setting may be overridden by \fBQCustomPlot::setAntialiasedElements\fP and \fBQCustomPlot::setNotAntialiasedElements\fP\&. 
.PP
Definition at line \fB10746\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setBrush (const QBrush & brush)"
The brush is used to draw basic fills of the plottable representation in the plot\&. The Fill can be a color, gradient or texture, see the usage of QBrush\&.
.PP
For example, the \fBQCPGraph\fP subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush\&.
.PP
\fBSee also\fP
.RS 4
\fBsetPen\fP 
.RE
.PP

.PP
Definition at line \fB10773\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setKeyAxis (\fBQCPAxis\fP * axis)"
The key axis of a plottable can be set to any axis of a \fBQCustomPlot\fP, as long as it is orthogonal to the plottable's value axis\&. This function performs no checks to make sure this is the case\&. The typical mathematical choice is to use the x-axis (\fBQCustomPlot::xAxis\fP) as key axis and the y-axis (\fBQCustomPlot::yAxis\fP) as value axis\&.
.PP
Normally, the key and value axes are set in the constructor of the plottable (or \fBQCustomPlot::addGraph\fP when working with QCPGraphs through the dedicated graph interface)\&.
.PP
\fBSee also\fP
.RS 4
\fBsetValueAxis\fP 
.RE
.PP

.PP
Definition at line \fB10789\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setName (const QString & name)"
The name is the textual representation of this plottable as it is displayed in the legend (\fBQCPLegend\fP)\&. It may contain any UTF-8 characters, including newlines\&. 
.PP
Definition at line \fB10724\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setPen (const QPen & pen)"
The pen is used to draw basic lines that make up the plottable representation in the plot\&.
.PP
For example, the \fBQCPGraph\fP subclass draws its graph lines with this pen\&.
.PP
\fBSee also\fP
.RS 4
\fBsetBrush\fP 
.RE
.PP

.PP
Definition at line \fB10759\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setSelectable (\fBQCP::SelectionType\fP selectable)"
Sets whether and to which granularity this plottable can be selected\&.
.PP
A selection can happen by clicking on the \fBQCustomPlot\fP surface (When \fBQCustomPlot::setInteractions\fP contains \fBQCP::iSelectPlottables\fP), by dragging a selection rect (When \fBQCustomPlot::setSelectionRectMode\fP is \fBQCP::srmSelect\fP), or programmatically by calling \fBsetSelection\fP\&.
.PP
\fBSee also\fP
.RS 4
\fBsetSelection\fP, \fBQCP::SelectionType\fP 
.RE
.PP

.PP
Definition at line \fB10876\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setSelection (\fBQCPDataSelection\fP selection)"
Sets which data ranges of this plottable are selected\&. Selected data ranges are drawn differently (e\&.g\&. color) in the plot\&. This can be controlled via the selection decorator (see \fBselectionDecorator\fP)\&.
.PP
The entire selection mechanism for plottables is handled automatically when \fBQCustomPlot::setInteractions\fP contains iSelectPlottables\&. You only need to call this function when you wish to change the selection state programmatically\&.
.PP
Using \fBsetSelectable\fP you can further specify for each plottable whether and to which granularity it is selectable\&. If \fIselection\fP is not compatible with the current \fBQCP::SelectionType\fP set via \fBsetSelectable\fP, the resulting selection will be adjusted accordingly (see \fBQCPDataSelection::enforceType\fP)\&.
.PP
emits the \fBselectionChanged\fP signal when \fIselected\fP is different from the previous selection state\&.
.PP
\fBSee also\fP
.RS 4
\fBsetSelectable\fP, \fBselectTest\fP 
.RE
.PP

.PP
Definition at line \fB10829\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setSelectionDecorator (\fBQCPSelectionDecorator\fP * decorator)"
Use this method to set an own \fBQCPSelectionDecorator\fP (subclass) instance\&. This allows you to customize the visual representation of selected data ranges further than by using the default \fBQCPSelectionDecorator\fP\&.
.PP
The plottable takes ownership of the \fIdecorator\fP\&.
.PP
The currently set decorator can be accessed via \fBselectionDecorator\fP\&. 
.PP
Definition at line \fB10849\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "void QCPAbstractPlottable::setValueAxis (\fBQCPAxis\fP * axis)"
The value axis of a plottable can be set to any axis of a \fBQCustomPlot\fP, as long as it is orthogonal to the plottable's key axis\&. This function performs no checks to make sure this is the case\&. The typical mathematical choice is to use the x-axis (\fBQCustomPlot::xAxis\fP) as key axis and the y-axis (\fBQCustomPlot::yAxis\fP) as value axis\&.
.PP
Normally, the key and value axes are set in the constructor of the plottable (or \fBQCustomPlot::addGraph\fP when working with QCPGraphs through the dedicated graph interface)\&.
.PP
\fBSee also\fP
.RS 4
\fBsetKeyAxis\fP 
.RE
.PP

.PP
Definition at line \fB10805\fP of file \fBqcustomplot\&.cpp\fP\&.
.SS "\fBQCPAxis\fP * QCPAbstractPlottable::valueAxis () const\fC [inline]\fP"

.PP
Definition at line \fB3313\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBQCPAxis\fP\fC [friend]\fP"

.PP
Definition at line \fB3386\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCPPlottableLegendItem\fP\fC [friend]\fP"

.PP
Definition at line \fB3387\fP of file \fBqcustomplot\&.h\fP\&.
.SS "friend class \fBQCustomPlot\fP\fC [friend]\fP"

.PP
Definition at line \fB3385\fP of file \fBqcustomplot\&.h\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "bool QCPAbstractPlottable::mAntialiasedFill\fC [protected]\fP"

.PP
Definition at line \fB3358\fP of file \fBqcustomplot\&.h\fP\&.
.SS "bool QCPAbstractPlottable::mAntialiasedScatters\fC [protected]\fP"

.PP
Definition at line \fB3358\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QBrush QCPAbstractPlottable::mBrush\fC [protected]\fP"

.PP
Definition at line \fB3360\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPointer<\fBQCPAxis\fP> QCPAbstractPlottable::mKeyAxis\fC [protected]\fP"

.PP
Definition at line \fB3361\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QString QCPAbstractPlottable::mName\fC [protected]\fP"

.PP
Definition at line \fB3357\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPen QCPAbstractPlottable::mPen\fC [protected]\fP"

.PP
Definition at line \fB3359\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCP::SelectionType\fP QCPAbstractPlottable::mSelectable\fC [protected]\fP"

.PP
Definition at line \fB3362\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPDataSelection\fP QCPAbstractPlottable::mSelection\fC [protected]\fP"

.PP
Definition at line \fB3363\fP of file \fBqcustomplot\&.h\fP\&.
.SS "\fBQCPSelectionDecorator\fP* QCPAbstractPlottable::mSelectionDecorator\fC [protected]\fP"

.PP
Definition at line \fB3364\fP of file \fBqcustomplot\&.h\fP\&.
.SS "QPointer<\fBQCPAxis\fP> QCPAbstractPlottable::mValueAxis\fC [protected]\fP"

.PP
Definition at line \fB3361\fP of file \fBqcustomplot\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OmronPID from the source code\&.
